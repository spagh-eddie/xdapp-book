<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wormhole Development Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction/introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="dapps/0_xdappOverview.html"><strong aria-hidden="true">1.</strong> xDapps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dapps/1_defiBasics.html"><strong aria-hidden="true">1.1.</strong> Ecosystem Basics</a></li><li class="chapter-item expanded "><a href="dapps/2_crossChainInteroperability.html"><strong aria-hidden="true">1.2.</strong> Blockchain Interoperability</a></li><li class="chapter-item expanded "><a href="dapps/3_xdataxassets.html"><strong aria-hidden="true">1.3.</strong> xData &amp; xAssets</a></li><li class="chapter-item expanded "><a href="dapps/4_whatIsanXdapp.html"><strong aria-hidden="true">1.4.</strong> What is an xDapp?</a></li><li class="chapter-item expanded "><a href="dapps/5_advantages.html"><strong aria-hidden="true">1.5.</strong> Advantages of xDapps</a></li></ol></li><li class="chapter-item expanded "><a href="wormhole/0_wormholeOverview.html"><strong aria-hidden="true">2.</strong> Wormhole</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wormhole/1_whatIsWormhole.html"><strong aria-hidden="true">2.1.</strong> What is Wormhole?</a></li><li class="chapter-item expanded "><a href="wormhole/2_architectureOverview.html"><strong aria-hidden="true">2.2.</strong> Architecture Overview</a></li><li class="chapter-item expanded "><a href="wormhole/3_coreLayerContracts.html"><strong aria-hidden="true">2.3.</strong> Core Layer Contracts</a></li><li class="chapter-item expanded "><a href="wormhole/4_vaa.html"><strong aria-hidden="true">2.4.</strong> VAA: Verified Action Approval</a></li><li class="chapter-item expanded "><a href="wormhole/5_guardianNetwork.html"><strong aria-hidden="true">2.5.</strong> Guardian Network</a></li><li class="chapter-item expanded "><a href="wormhole/6_relayers.html"><strong aria-hidden="true">2.6.</strong> Relayers</a></li><li class="chapter-item expanded "><a href="wormhole/7_xAssetBridge.html"><strong aria-hidden="true">2.7.</strong> xAsset Bridge</a></li><li class="chapter-item expanded "><a href="wormhole/8_wormchain.html"><strong aria-hidden="true">2.8.</strong> Wormchain</a></li></ol></li><li class="chapter-item expanded "><a href="dapps/architecture/0_dappDesign.html"><strong aria-hidden="true">3.</strong> xDapp Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dapps/architecture/1_keyConsiderations.html"><strong aria-hidden="true">3.1.</strong> Key Considerations</a></li><li class="chapter-item expanded "><a href="dapps/architecture/2_ecosystems.html"><strong aria-hidden="true">3.2.</strong> Ecosystems</a></li><li class="chapter-item expanded "><a href="dapps/architecture/3_protocolDesign.html"><strong aria-hidden="true">3.3.</strong> Protocol Design</a></li><li class="chapter-item expanded "><a href="dapps/architecture/4_topology.html"><strong aria-hidden="true">3.4.</strong> Topology</a></li><li class="chapter-item expanded "><a href="dapps/architecture/5_relayers.html"><strong aria-hidden="true">3.5.</strong> Relayers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Developing xDapps</li><li class="chapter-item expanded "><a href="technical/env/environments.html"><strong aria-hidden="true">4.</strong> Environment Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/env/tilt.html"><strong aria-hidden="true">4.1.</strong> Tilt (Devnet)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/env/troubleshooting.html"><strong aria-hidden="true">4.1.1.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="technical/env/wlv.html"><strong aria-hidden="true">4.2.</strong> Wormhole Local Validator</a></li><li class="chapter-item expanded "><a href="technical/env/testnet.html"><strong aria-hidden="true">4.3.</strong> Testnet</a></li><li class="chapter-item expanded "><a href="technical/env/tooling.html"><strong aria-hidden="true">4.4.</strong> Tooling</a></li></ol></li><li class="chapter-item expanded "><a href="technical/overview.html"><strong aria-hidden="true">5.</strong> Contract Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/evm/overview.html"><strong aria-hidden="true">5.1.</strong> EVM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/evm/coreLayer.html"><strong aria-hidden="true">5.1.1.</strong> Core Layer</a></li><li class="chapter-item expanded "><a href="technical/evm/tokenLayer.html"><strong aria-hidden="true">5.1.2.</strong> Token Bridge Module</a></li><li class="chapter-item expanded "><a href="technical/evm/nftLayer.html"><strong aria-hidden="true">5.1.3.</strong> NFT Bridge Module</a></li><li class="chapter-item expanded "><a href="technical/evm/relayer.html"><strong aria-hidden="true">5.1.4.</strong> Relayer Module</a></li><li class="chapter-item expanded "><a href="technical/evm/bestPractices.html"><strong aria-hidden="true">5.1.5.</strong> Best Practices</a></li></ol></li><li class="chapter-item expanded "><a href="technical/solana/overview.html"><strong aria-hidden="true">5.2.</strong> Solana</a></li><li class="chapter-item expanded "><a href="technical/cosmos/overview.html"><strong aria-hidden="true">5.3.</strong> Cosmos</a></li><li class="chapter-item expanded "><a href="technical/algorand/overview.html"><strong aria-hidden="true">5.4.</strong> Algorand</a></li><li class="chapter-item expanded "><a href="technical/near/overview.html"><strong aria-hidden="true">5.5.</strong> Near</a></li><li class="chapter-item expanded "><a href="technical/aptos/overview.html"><strong aria-hidden="true">5.6.</strong> Aptos</a></li></ol></li><li class="chapter-item expanded "><a href="technical/relayer/overview.html"><strong aria-hidden="true">6.</strong> Relayers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/relayer/genericRelayer.html"><strong aria-hidden="true">6.1.</strong> Generic Relayers</a></li><li class="chapter-item expanded "><a href="technical/relayer/specializedRelayers.html"><strong aria-hidden="true">6.2.</strong> Specialized Relayers</a></li></ol></li><li class="chapter-item expanded "><a href="technical/typescript/overview.html"><strong aria-hidden="true">7.</strong> Wormhole Typescript SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technical/typescript/attestingToken.html"><strong aria-hidden="true">7.1.</strong> Token Registration</a></li><li class="chapter-item expanded "><a href="technical/typescript/tokenTransfer.html"><strong aria-hidden="true">7.2.</strong> Token Transfer Basics</a></li><li class="chapter-item expanded "><a href="technical/typescript/cross-ecosystem-transfer.html"><strong aria-hidden="true">7.3.</strong> Cross-Ecosystem Transfer</a></li><li class="chapter-item expanded "><a href="technical/typescript/using-relayer.html"><strong aria-hidden="true">7.4.</strong> Using Relayers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/overview.html"><strong aria-hidden="true">8.</strong> Other Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/glossary.html"><strong aria-hidden="true">8.1.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="reference/usefulLinks.html"><strong aria-hidden="true">8.2.</strong> Useful Links</a></li><li class="chapter-item expanded "><a href="reference/contracts.html"><strong aria-hidden="true">8.3.</strong> Deployed Contracts</a></li><li class="chapter-item expanded "><a href="reference/rpcnodes.html"><strong aria-hidden="true">8.4.</strong> RPC Nodes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wormhole Development Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wormhole-foundation/xdapp-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="welcome-to-the-wormhole-xdapp-book"><a class="header" href="#welcome-to-the-wormhole-xdapp-book">Welcome to the Wormhole xDapp Book!</a></h2>
<p>This guide aims to help you in your journey as a cross-chain developer by explaining the core concepts of Wormhole and xDapp development.</p>
<p>We'll start by outlining the most important aspects of Wormhole and the considerations which must be taken when developing an xDapp. After that, the second portion of the book helps you set up a development environment and get started writing actual code. By the end of this guide, you should be ready to build and deploy your first xDapp.</p>
<p>While this document doesn't assume you have experience with any particular technologies, a general understanding of blockchain development will help you get up to speed.</p>
<p>Ready to step <em>into the wormhole</em>?</p>
<hr />
<p>For additional resources, see the <strong>Reference</strong> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-introduction-to-xdapps"><a class="header" href="#an-introduction-to-xdapps">An Introduction to xDapps</a></h1>
<p>This chapter aims to give you a clear understanding of what xDapps are and why they're gaining traction in the blockchain development community.</p>
<p>To start, let's go over the current state of the decentralized finance (De-Fi) ecosystem, the emerging role of xDapps and the advantages they have over conventional Dapps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem-basics"><a class="header" href="#ecosystem-basics">Ecosystem Basics</a></h1>
<p>Since the launch of Bitcoin in 2009, the cryptocurrency and decentralized computing ecosystem has rapidly evolved and expanded. The ecosystem now includes hundreds of blockchains, often also referred to as <strong>Layer 1s</strong>.</p>
<p>Prior to 2015, blockchain transactions were limited in their capacities, typically being used to transfer funds from one user to another. This changed with the intoduction of Ethereum and smart contracts. Smart contracts allowed developers to perform arbitrary on-chain computation as part of a blockchain transaction, opening the door for blockchain technology to become a global computing platform. These innovations laid the groundwork for the creation of <strong>Decentralized Applications</strong> or <strong>Dapps</strong>.</p>
<p>Now, a rich ecosystem of Dapps exists across an array of smart-contract-enabled blockchains. These Dapps provide a number of services across categories like:</p>
<ul>
<li>Decentralized Exchanges (DEXs)</li>
<li>Decentralized Autonomous Organizations (DAOs)</li>
<li>Borrow-Lend Platforms</li>
<li>Decentralized Games</li>
<li>NFT Protocols</li>
<li>Metaverse Platforms</li>
<li>and more</li>
</ul>
<p>However, Dapps are not without limitations, many of which are tied to their underlying blockchains.</p>
<p>Two notable limitations are that blockchains have no access to off-chain data and no mechanism to interact with other blockchains. These limitations have lead to a fractured ecosystem where each blockchain is closed off from the others by default. That means assets native to one chain are not accessible on another, and some services can't be leveraged on particular chains altogether.</p>
<p>Blockchain developers are now aiming to solve these interoperability problems to create a unified ecosystem. In this new cross-chain ecosystem, people can move beyond being users of individual blockchains and take advantage of Web3 on a broader scale.</p>
<hr />
<p>In the next section, we'll discuss the history and challenges of cross-chain interoperability, as well as introduce the role Wormhole plays in the future of this space.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-interoperability"><a class="header" href="#blockchain-interoperability">Blockchain Interoperability</a></h1>
<p>Because blockchains are siloed by nature, individual cryptocurrencies being bound to their own chains has been a longtime limitation of blockchain technology. The first attempt at solving this problem was the creation of cryptocurrency exchanges like Coinbase and Binance. Today these are refered to as centralized exchanges (CEXs).</p>
<p>Centralized exchanges play an important role in cryptocurrency, but they are not a complete solution for blockchain interoperability for two primary reasons: (1) they're centralized, which is counterproductive to creating a decentralized platform, and (2) they deal only with tokens.</p>
<p>To solve the centralization problems with CEXs, decentralized exchanges (DEXs) were created. A DEX operates inside a smart contract runtime and can be as decentralized as the blockchain it runs on. Unfortunately, a DEX is only able to utilize the tokens on its native blockchain. In order to obtain a token which is not native to that chain, the DEX must be used in combination with a <strong>bridge</strong>.</p>
<p><strong>Bridges</strong> are complex and will be discussed at length in a later section. For now, we can categorize bridges as applications which 'lock' assets on one chain in exchange for <strong>wrapped assets</strong> on another chain. The wrapped assets can then be exchanged for the original 'backing' asset.</p>
<p>There are some other essential things you should know about bridges before going further:</p>
<ul>
<li>Bridges are capable of being decentralized in theory, but are often quite centralized in practice.</li>
<li>Bridges are currently the only way to hold a token on a chain other than its 'native' chain. If you're holding ETH on a chain other than Ethereum, it is, by definition, a wrapped token.</li>
<li>Bridges are all mutually incompatible with eachother. Using multiple bridges just makes 'double wrapped' tokens.</li>
<li>If tokens have become double wrapped after traversing multiple bridges or blockchains, there can be a complex unwrapping process to get back to the original token.</li>
</ul>
<p>This explains how the ecosystem arrived at its current state -- CEXs are a solution to siloed blockchains, DEXs are a simple response to CEXs, and DEXs have created a demand for bridges. Each solution in this timeline is an ad-hoc patch to the previous problem, and the current landscape of fractured liquidity, double wrapped tokens, isolated userbases and wallet incompatibilities is the result.</p>
<p>Adding to this complexity are blockchains moving toward being general-purpose computing platforms. As such, interoperability will require data structures that are more complex than tokens and operations that are more sophisticated than transfers.</p>
<p>More ad-hoc solutions would only be short-term fixes for long-term problems, so it's critical to design new primatives and core infrastructure that will allow the next generation of decentralized applications to move beyond these lingering limitations.</p>
<p>This is why Wormhole exists. Wormhole proposes a new way of developing applications which leverages the strengths of each blockchain while mitigating the problems of the current ecosystem.</p>
<hr />
<p>Rethinking the next generation of decentralized applications means dethroning the token as the fundamental atomic unit of blockchains. We'll expand on this change in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xdata-and-xassets"><a class="header" href="#xdata-and-xassets">xData and xAssets</a></h1>
<p>High on the wishlist of blockchain features is the ability to detach tokens from their native chains. It is a tremendous limitation that ETH only exists on Ethereum, MATIC only exists on Polygon and SOL only exists on Solana. It would be far more useful if those assets were able to move freely, independent of their native blockchains.</p>
<p>That thought underpins the idea of an <strong>xAsset</strong>, which could be considered a next-generation <em>wrapped token</em>. In a sense, xAssets exist on a layer <em>outside</em> of the blockchain ecosystem, and so are able to transact on a variety of blockchains. An xAsset is chain- and path- agnostic, so it retains fungibility regardless of where it travels. xAssets can also move fluidly around the blockchain ecosystem without ever becoming double-wrapped. </p>
<p>Now that we've established the idea of an xAsset, you might think they're an excellent atomic unit for solving interoperability challenges. However, xAssets are just one step short of the real solution. Let's take a step back: blockchains now process arbitrary data, and some of that data just happens to represent assets. The full solution then, is to create <strong>xData</strong>.</p>
<p>xData is akin to an xAsset in that it exists in its own layer independent of any blockchain, which makes xData accessible by <em>all</em> blockchains. The  difference is that xData represents arbitrary data rather the token information represented by an xAsset.</p>
<p>Cross-chain interoperability then becomes a matter of creating, consuming and managing xData. Once blockchains have the ability to read and write data into a shared, global reservior, application design can take on innovative new dimensions.</p>
<hr />
<p>Later in this document, we'll delve deeper into how Wormhole implements this <a href="dapps/../wormhole/3_coreLayerContracts.html">xData layer</a> (also referred to as the 'Core' layer of Wormhole), but for now let's talk about how xData can be used to create xDapps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-an-xdapp"><a class="header" href="#what-is-an-xdapp">What is an xDapp?</a></h1>
<p>The term <strong>xDapp</strong> is short for &quot;Cross-Chain Decentralized Application&quot;. At first glance, this might give the impression that xDapps are simply Dapps that  do cross-chain things. However, once you start building decentralized products designed to operate across a variety of blockchains and runtimes, it becomes clear that these applications are architected in a fundamentally different way than traditional Dapps.</p>
<p>xDapps have the capacity to perform all the operations of traditional Dapps, but they are also able to utilize xData. xData allows xDapp developers to build from a top-down, message-passing approach, rather than the bottom-up world of Dapp development. The Wormhole Core Layer implements xData, which acts as a shared repository of data across the entire Wormhole ecosystem.</p>
<p>Something we'll explore further in the upcoming xDapp Architecture chapter is the philosophy of <a href="dapps/./architecture/3_protocolDesign.html"><strong>Protocol-First Design</strong></a>. Protocol First Design is an approach to building decentralized applications where the first order of business is to lay out your application into a series of data structures, APIs and message payloads. Once you've laid out your application into a high-level protocol, the protocol acts as an agreement to which all components must adhere. From there, the smart contracts underlying the protocol can be considered an implementation detail.</p>
<p>If you're familiar with web2 development, you might notice that this philosophy is analogous to microservice architecture. This is no coincidence, as similar problems should expect to be solved by similar solutions, and the Wormhole Core Layer has a number of parallels to the OSI Network Model.</p>
<p>Thus, a more fitting depiction of xDapps might be to see them as <strong>Distributed Decentralized Applications</strong> with multiple, specialized components working in unison to deliver a smooth, unified user experience across a variety of layer 1 ecosystems.</p>
<hr />
<p>In the next section, we'll summarize the concrete advantages which xDapps built on Wormhole have over traditional Dapps today.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advantages-of-xdapps"><a class="header" href="#advantages-of-xdapps">Advantages of xDapps</a></h1>
<p>Here are a few xDapp features that are making an impact across blockchain technologies:</p>
<ul>
<li>
<p><strong>Expanded User Base</strong> - Rather than being limited to the users of one blockchain, any user on any blockchain in the ecosystem can interact with an xDapp.</p>
</li>
<li>
<p><strong>Unified Liquidity</strong> - Liquidity fragmentation is a major problem in the current ecosystem. Unlike traditional tokens, xAssets can be pooled and moved anywhere.</p>
</li>
<li>
<p><strong>Decentralization</strong> - Cross-chain solutions today usually involve centralized exchanges or bridges. However, Wormhole has been designed to be decentralized from day one, and eventually totally trustless.</p>
</li>
<li>
<p><strong>Increased Performance</strong> - xDapps are able to utilize the strengths of each blockchain. With xDapps, expensive computations can be offloaded onto high-performance platforms, final settlement can take place on a preferred chain, and data can be stored wherever is cheapest.</p>
</li>
<li>
<p><strong>Broader Market Reach</strong> - Because xAssets move freely through the ecosystem, they can be listed on a variety of exchanges and custodied on any blockchain.</p>
</li>
<li>
<p><strong>Increased Extensibility and Composability</strong> - xDapps can utilize anything across the ecosystem, including other xDapps, expanding upon the composability and openness of smart contracts. </p>
</li>
<li>
<p><strong>Futureproofing</strong> - As new environments and protocols join the decentralized ecosystem, the connected nature of the Wormhole ecosystem allows existing protocols to expand and support them.</p>
</li>
</ul>
<p>Now that you have an understanding of what xDapps are and the advantages they offer, let's move on to the next chapter where we will delve into how Wormhole works and how it enables the creation of these next-generation protocols.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wormhole"><a class="header" href="#wormhole">Wormhole</a></h1>
<p>In the previous chapter, we established concepts like xDapps, xData and xAssets. In this chapter, we'll focus on the inner workings of the Wormhole ecosystem and how they power these ideas.</p>
<p>By the end of this chapter, you'll have a clear understanding of what Wormhole is, what its key components are and how each component comes together to create a powerful, new cross-chain ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-wormhole"><a class="header" href="#what-is-wormhole">What is Wormhole?</a></h1>
<p>Wormhole V1 was introduced in 2020 by Certus One, and was initially conceived as a traditional token bridge between Ethereum and Solana. It served as the first bridge on Solana and was responsible for bootstrapping a large amount of the liquidity in the early Solana and Serum ecosystems.</p>
<p>However, despite its beginnings as a token bridge, Wormhole quickly grew beyond Solana and token transfers.</p>
<p>Wormhole v2 launched in August 2021 as a decentralized generic interoperability protocol for multiple blockchain ecosystems with initial support for Solana, Terra, Ethereum and Binance Smart Chain.</p>
<p>Over the past year, Wormhole has evolved to support an ever-growing list of blockchains across an unrivaled number of smart contract runtimes.</p>
<p>While Wormhole is a generic interoperability protocol, it is also an ecosystem and platform for developers to grow the decentralized computing space. Wormhole consists of multiple modular swap-in components that can be leveraged independently and supports a increasing number of composible applications built by numerous teams.</p>
<hr />
<p>In the next section, we'll go over the major components of the Wormhole ecosystem and how they fit together to enable the cross-chain functionality required to develop xDapps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Wormhole is a complex ecosystem with several noteworthy components. Before we go into each component in depth, let's talk about the names of the major pieces and how they fit together.</p>
<p><img src="wormhole/../diagrams/images/architecture.PNG" alt="Architecture Diagram" /></p>
<h3 id="on-chain-components"><a class="header" href="#on-chain-components">On-Chain Components</a></h3>
<ul>
<li>
<p><strong>xDapp Contracts</strong> - Contracts developed by xDapp developers. They receive transactions from the end user and then interact with other xDapp contracts and Wormhole Ecosystem Contracts in order to provide their service.</p>
</li>
<li>
<p><strong>Ecosystem Contracts</strong> - Contracts subject to Wormhole governance which live inside the Wormhole Ecosystem. Their job is to provide the feature suite of Wormhole to xDapp developers.</p>
<ul>
<li>
<p><strong>Core Contracts</strong> - Primary ecosystem contracts. These are the contracts which the Guardians observe and which fundamentally allow for cross-chain communication.</p>
</li>
<li>
<p><strong>xAsset Contracts</strong> - Contracts that allow normal tokens to be converted to xAssets and enable these xAssets to be bridged.</p>
</li>
<li>
<p><strong>Relay Contracts</strong> - <em>in development*</em> - Contracts that allow xDapps to send messages to a specific blockchain via the decentralized Generic Relayer network.</p>
</li>
<li>
<p><strong>Gas Oracle</strong> - <em>in development*</em> - Oracle for recommended fair gas prices across the ecosystem.</p>
</li>
<li>
<p><strong>Worm Router Contracts</strong> - <em>in development*</em> - Contracts that allow developers to make their Dapp an xDapp that users on any Wormhole supported chain can interac with purely through clientside code.</p>
</li>
</ul>
</li>
</ul>
<h3 id="off-chain-components"><a class="header" href="#off-chain-components">Off-Chain Components</a></h3>
<ul>
<li>
<p><strong>Guardian Network</strong> - Validators that exist in their own p2p network. Guardians observe the Core Contract on each supported chain and produce VAAs (signed messages) when those contracts receive an interaction.</p>
</li>
<li>
<p><strong>Guardian</strong> - One of 19 validators in the Guardian Network that contributes to the VAA multisig.</p>
</li>
<li>
<p><strong>Spy</strong> - Validators on the Guardian Network which are not part of the Guardian set. A spy can observe and forward network traffic, which helps scale up VAA distribution.</p>
</li>
<li>
<p><strong>VAAs</strong> - Verifiable Action Approvals (VAAs) are the key piece of data in the Wormhole ecosystem, containing the messages emitted by xDapps along with information such as what contract emitted the message. The VAAs are signed by the Guardians and need 13/19 signatures to be considered authentic.</p>
</li>
<li>
<p><strong>Specialized Relayers</strong> - Relayers that only handle VAAs for a specific protocol or xDapp. They can execute custom logic off-chain, which can reduce gas costs and increase cross-chain compatibility. Currently, xDapp developers are responsible for developing and hosting specialized relayers.</p>
</li>
<li>
<p><strong>Generic Relayers</strong> - <em>in development*</em> - A decentralized relayer network which delivers messages that are requested on-chain via the Wormhole Relay Contract.</p>
</li>
<li>
<p><strong>Wormchain</strong> - <em>in development*</em> - A purpose-built cosmos blockchain which aids the Guardian Network and allows for formal interaction with the Guardians.</p>
</li>
</ul>
<p>*Features listed as <em>in development</em> are not yet available.</p>
<hr />
<p>In the next section, we'll give an overview of how the Wormhole Guardian network creates VAAs along with a look at the key design considerations that underpin the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-contracts"><a class="header" href="#core-contracts">Core Contracts</a></h1>
<p>The Core Contracts are the mechanism by which all Wormhole messages are emitted. All xDapps either interact directly with the Core Contract or interact with another contract that does. There is one Core Contract on each blockchain in the ecosystem, and this is the contract which the Guardians are required to observe. </p>
<p>The Wormhole Core Contracts are one of the most pivotal pieces of the Wormhole ecosystem. They serve as a great place to start when learning about how data flows through the ecosystem.</p>
<p>In general, Core Contracts are simple and can be broekn down to a <strong>sending</strong> and <strong>receiving</strong> side, which we'll define next.</p>
<h3 id="sending"><a class="header" href="#sending">Sending</a></h3>
<p>Below is the mechanism by which Wormhole messages (aka Verified ACtion Approval, VAA) are emitted:</p>
<pre><code>publishMessage(
    int nonce,
    byte[] payload,
    int consistencyLevel
) returns int sequenceNumber
</code></pre>
<p>Let's break it down a bit:</p>
<ul>
<li>
<p><strong>payload</strong> - The content of the emitted message and an arbitrary byte array. It may be capped to a certain maximum length due to the constraints of individual blockchains.</p>
</li>
<li>
<p><strong>consistencyLevel</strong> - The number of blocks which the Guardians should wait prior to emitting a VAA for this message. This number is usually either 1 or equal to the chain's finality period. This is a defense against transactions being orphaned.</p>
</li>
<li>
<p><strong>nonce</strong> -  An index number for the message that is used to produce Batch VAAs. How this is generated is elaborated in the <a href="wormhole/../technical/evm/coreLayer.html">CoreLayer</a> section.</p>
</li>
<li>
<p><strong>sequenceNumber</strong> - A unique index number for the message. When combined with the emitter contract address and emitter chain ID, the corresponding VAA can be retrieved from a guardian network node.</p>
</li>
</ul>
<p>The implementation strategy for publishMessage differs by chain, but the general strategy consists of the Core Contract posting the emitterAddress (the contract which called publishMessage), sequenceNumber, and consistencyLevel into the blockchain logs. Once the desired consistencyLevel has elapsed and the message passes all of the Guardians' optional checks, the Guardian Network will produce the requested VAAs.</p>
<p>Currently there are no fees to publish a message (with the exception of publishing on Solana) but this is not guaranteed to always be the case in the future.</p>
<h3 id="receiving"><a class="header" href="#receiving">Receiving</a></h3>
<p>Below is the mechanism by which VAAs are received:</p>
<pre><code>parseAndVerifyVAA( byte[] VAA )
</code></pre>
<p>When passed a VAA, this function will either return the payload and associated metadata for the VAA or throw an exception. An exception should only ever throw if the VAA fails signature verification, indicating the VAA is invalid or inauthentic in some form.</p>
<hr />
<h2 id="multicasting"><a class="header" href="#multicasting">Multicasting</a></h2>
<p>Let's take a moment to point out that there is no destination address or chain in these functions.</p>
<p>VAAs simply attest that &quot;this contract on this chain said this thing.&quot; Therefore, VAAs are multicast by default and will be verified as authentic on any chain they are brought to.</p>
<p>This multicast-by-default model is integral to the design. Having this multicast capacity makes it easy to synchronize state across the entire ecosystem, because a single blockchain can make its data available to every chain in a single action with low latency. This reduces the complexity of the n^2 problems encountered by routing data to a large number of blockchains.</p>
<p>Use cases where the message has an intended recipient or is only meant to be consumed a single time must be handled in logic outside the Core Contract. There are standard practices for accomplishing these features later on in the code examples, and some ecosystem contracts (namely Token Bridge &amp; the Relaying contract) handle this on behalf of downstream consumers.</p>
<p>Lastly, because the VAA creation is separate from relaying, there is <em>no additional cost</em> to the multicast model when a single chain is being targetted. If the data isn't needed on a certain blockchain, don't relay it there, and it won't cost anything.</p>
<hr />
<p>In our next section, we'll dive into the technical specfications of the VAA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vaas-verified-action-approvals"><a class="header" href="#vaas-verified-action-approvals">VAAs (Verified Action Approvals)</a></h1>
<p>VAAs are the core messaging primative in Wormhole. You can think of them as packets of xData that are emitted any time an xDapp contract interacts with the Core Contract.</p>
<p>The basic VAA has two components--a Header and a Body.</p>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<pre><code>byte        version                  (VAA Version)
u32         guardian_set_index       (Indicates which guardian set is signing)
u8          len_signatures           (Number of signatures stored)
[][66]byte  signatures               (Collection of ecdsa signatures)
</code></pre>
<p>The Header is used by the Core Contract to determine the authenticity of the VAA, but can generally be ignored by other consumers.</p>
<h2 id="body"><a class="header" href="#body">Body</a></h2>
<pre><code>u32         timestamp                 (Timestamp of the block where the source transaction occurred)
u32         nonce                     (A grouping number)
u16         emitter_chain             (Wormhole ChainId of emitter contract)
[32]byte    emitter_address           (Emitter contract address, in Wormhole format)
u64         sequence                  (Strictly increasing sequence, tied to emitter address &amp; chain)
u8          consistency_level         (How many blocks were waited before emitting this VAA)
[]byte      payload                   (VAA message content)
</code></pre>
<p>The Body is the relevant information for consumers and is handed back from parseAndVerifyVAA. Because the emitterAddress is included as part of the Body, the developer is able to tell if this VAA originated from a trusted contract.</p>
<p>VAAs are uniquely indexed by their emitterChain, emittedAddress and sequence. They can be obtained by querying a node in the Guardian Network with this information.</p>
<p>Because baseline VAAs have no destination, they are effectively multicast. They will be verified as authentic by any Core Contract on any chain in the network. If a VAA has a specific destionation, it is entirely the responsibility of relayers to complete that delivery appropriately.</p>
<h2 id="batch-vaas"><a class="header" href="#batch-vaas">Batch VAAs</a></h2>
<p>Certain blockchains support version 2 VAAs, also referred to as <strong>Batch VAAs</strong> which are designed to provide an easier paradigm for composability and better gas efficiency when multiple cross-chain actions are involved in a single transaction.</p>
<p>Batch VAAs are designed to be automatically generated for all messages that come from a single transaction. </p>
<p>In an extreme composability scenario or advanced integration, there may be some messages in a transaction that may not be relevant to one another. To control the create of additional batches, some messages can be created with the same <code>nonce</code> to <em>additionally</em> group them.</p>
<p>It is of note that Single VAAs will always be emitted for each message generated, regardless of it they are contained in a Batch VAA or not.</p>
<p>Go <a href="wormhole/../technical/evm/coreLayer.html">here</a> for a more detailed description of how Batch VAAs are generated.</p>
<p><em>Note: Batch VAAs are not currently live on mainnet, but will have initial support on all EVM chains when they launch.</em></p>
<blockquote>
<p>How to leverage Batch VAAs </p>
<p>Imagine a transaction generates three messages (A, B, C) that a consuming contract needs to know about.</p>
<p>If each message is independent of each other, the consuming contract can handle and validate each of these VAAs individually like [A], [B], [C].</p>
<p>If all of the messages are related to each other, the consuming contract can handle and validate the Batch VAA of the entire transaction that is automatically generated like [A, B, C].</p>
<p>If only two of the messages are related to each other, say A and C, the same <code>nonce</code> can be used for those two messages to generate an additional Batch VAA and the consuming contract can then handle and validate two sets of VAAs like [A, C] and [B].</p>
</blockquote>
<hr />
<p>In the next section, we'll give an overview of how the Wormhole Guardian network creates VAAs along with a look at the key design considerations that underpin the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guardian-network"><a class="header" href="#guardian-network">Guardian Network</a></h1>
<p>The Guardian Network is designed to serve as Wormhole's oracle component, and the entire Wormhole ecosystem is founded on its technical underpinnings. It is the most critical element of the Wormhole ecosystem, and represents the single most important component to learn about if you want a deep understanding of Wormhole.</p>
<p>To understand not just <em>how</em> the Guardian Network works, but <em>why</em> it works the way it does, let's first take a step back and go over the key design considerations. To become the best-in-class interoperability platform, there were five critical features Wormhole needed to have:</p>
<ol>
<li><strong>Decentralization</strong> - Control of the network needs to be distributed amongst many parties.</li>
<li><strong>Modularity</strong> - Disparate parts of the ecosystem such as the oracle, relayer, applications, etc, should be kept as separate and modular as possible so they can be designed, modified and upgraded independently.</li>
<li><strong>Chain Agnosticism</strong> - Wormhole should be able to support not only EVM, but also chains like Solana, Algorand, Cosmos, and even platforms that haven't been created yet. It also should not have any one chain as a single point of failure.</li>
<li><strong>Scalablity</strong> - Wormhole should be able to secure a large amount of value immediately and be able to handle the large transaction volume.</li>
<li><strong>Upgradeability</strong> - As the decentralized computing ecosystem evolves, Wormhole will need to be able to change the implementation of its existing modules without breaking integrators.</li>
</ol>
<p>Next, let's go into how Wormhole achieves these one at a time.</p>
<h2 id="decentralization"><a class="header" href="#decentralization">Decentralization</a></h2>
<p>Decentralization is the biggest concern. Previous interoperability solutions have largely been entirely centralized, and even newer solutions utilizing things like adversarial relayers still tend to have single points of failure or collusion thresholds as low as 1 or 2.</p>
<p>When designing a decentralized oracle network, the first option to consider is likely a Proof-of-Stake (PoS) system--but this turns out to be a suboptimal solution. PoS is designed for blockchain consensus in smart-contract enabled environments, so it's less suitable when the network is verifying the output of many blockchains and not supporting its own smart contracts. While it looks appealing from a decentralization perspective, the network security remains unclear, and it can makes some of the other outlined goals more difficult to achieve. Let's explore other options.</p>
<p>The next option would be to rush straight for the finish line and use zero-knowledge proofs to secure the network. This would be the a good solution from a decentralization perspective, as it's literally trustless. However, zero-knowledge proofs are still a nascent technology and it's not really feasible to verify them on-chain, especially on chains with limited computational environments. That means a form of multisig will be needed to secure the network.</p>
<p>If we step back and look at the current De-Fi landscape, most of the top blockchains are secured by the same handful of validator companies. Currently, there are a limited number of companies in the world with the skills and capital to run top-notch validator companies.</p>
<p>If a protocol could unite a large number of those validator companies into a purpose-built consensus mechanism that's optimized for chain interoperability, that design would likely be more performant and secure than a network bootstrapped by a tokenomics model. Assuming the validators would be on board, how many could Wormhole realistically utilize?</p>
<p>If Wormhole were to use threshold signatures, the answer would basically be 'as many as are willing to participate.' However, threshold signatures have spotty support across the blockchain world, meaning it would be difficult and expensive to verify the signatures, ultimately limiting scalability and chain agnosticism. Thus, a t-schnorr multisig presents itself as the best option: cheap and well supported, despite the fact that its verification costs increases linearly with the number of signatures included.</p>
<p>All these things considered, 19 seems to be the maximum number and a good tradeoff. If 2/3 of the signatures are needed for consensus, then 13 signatures need to be verified on-chain, which remains reasonable from a gas-cost perspective.</p>
<p>Rather than securing the network with tokenomics, it is better to initially secure the network by involving robust companies which are heavily invested in the success of De-Fi as a whole. The 19 Guardians are not anonymous or small--they are many of the largest and most widely-known validator companies in cryptocurrency. The current list of Guardians can be viewed <a href="https://wormhole.com/network/">here</a></p>
<p>That's how we end up with the network of 19 Guardians, each with an equal stake and joined in a purpose-built Proof of Authority consensus mechanism. As threshold signatures become better supported, the Guardian set can expand, and once ZKPs are ubiquitous, the Guardian Network will become fully trustless.</p>
<p>With our perspective on Decentralization laid out, the remaining elements fall into place.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>The Guardian Network is robust and trustworthy by itself, so there'ss no need for components like the relayer to contribute to the security model. That makes Wormhole able to have simple components that are very good at the one thing they do. That way, Guardians only need to verify on-chain activity and produce VAAs while Relayers only need to interact with blockchains and deliver messages.</p>
<p>The signing scheme of the VAAs can be changed without affecting downstream users, and multiple relay mechanisms can exist independently. xAssets can be implemented purely at the application layer and xDapps can utilize whatever components suit them.</p>
<h2 id="chain-agnosticism"><a class="header" href="#chain-agnosticism">Chain Agnosticism</a></h2>
<p>Today, Wormhole supports a wider range of ecosystems than any other interoperability protocol because it uses simple tech (t-schnorr signatures), an adaptable, heterogenous relayer model, and a robust validator network.</p>
<p>Wormhole can expand to new ecosystems as quickly as a Core Contract can be developed for the smart contract runtime. Relayers don't need to be factored into the security model--they just need to be able to upload messages to the blockchain. The Guardians are able to observe every transaction on every chain, without taking shortcuts.</p>
<h2 id="scalability"><a class="header" href="#scalability">Scalability</a></h2>
<p>Wormhole scales well, as demonstrated by its ability to handle huge TVL and transaction volume--even during tumultuous events.</p>
<p>The requirements for running a Guardian are relatively heavy, as they need to run a full node for every single blockchain in the ecosystem. This is another reason why a limited number of robust validator companies are beneficial for this design.</p>
<p>However, once all the full nodes are running, the actual computation and network overheads of the Guardian Network become lightweight. The performance of the blockchains themselves tends to be the bottleneck in Wormhole, rather than anything happening inside the Guardian Network.</p>
<h2 id="upgradability"><a class="header" href="#upgradability">Upgradability</a></h2>
<p>Over time, the Guardian Set can be expanded beyond 19 with the use of threshold signatures. A variety of relaying models will emerge, each with their own strengths and weaknesses. ZKPs can be used on chains where they are well supported. The xDapp ecosystem will grow, and xDapps will become increasingly intermingled with eachother. There are very few APIs in Wormhole, and most items are implementation details from the perspective of an integrator. This creates a clear pathway towards a fully trustlessness interoperability layer which spans the entirety of decentralized computing.</p>
<hr />
<p>In the next section, we will talk about the role and responsbilities of relayers in the Wormhole ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayers"><a class="header" href="#relayers">Relayers</a></h1>
<p>All simple cross-chain processes on Wormhole essentially boil down to a three step process:</p>
<ol>
<li>Perform an action on chain A.</li>
<li>Retrieve the resulting VAA from the Guardian Network.</li>
<li>Perform an action on chain B using the VAA.</li>
</ol>
<p>Relayers play a key role in the final step of the process -- they can be thought of as the 'write' portion of interoperability, complementing the 'read' portion that Guardians provide.</p>
<p>The definition of a <em>Relayer</em> in the context of Wormhole is: Any process which delivers VAAs to a destination.</p>
<p>Unlike other interoperability protocols, Wormhole <strong>does not have a required relaying methodology</strong>.</p>
<p>In most designs there is a dedicated relaying mechanism which operates inside the protocol's trust boundaries. This means that the relayer either has an adversarial relationship to the oracle, or the relayer has trust assumptions and contributes to the protocol's security model. Relayers are usually a trusted party, are often also privileged, and developers are typically forced to use the relayer model built into the protocol.</p>
<p>In Wormhole, relayers are neither trusted nor privileged. This means relayers <strong>cannot jeopardize security, only liveness</strong>. Because Wormhole is designed to have a firm trust boundary at the level of the VAA, relayers have exactly the same capabilities as any regular, untrusted blockchain user.</p>
<p>From this perspective, relayers are just delivery trucks that deliver VAAs to their destination, and have no capacity to tamper with the delivery outcome. VAAs either get delivered or don't, which makes relayers analagous to the off-chain 'crank turners' of traditional Dapps.</p>
<p>As a result, Wormhole is able to facilitate a variety of heterogenous relaying mechanisms, and the developer is able to choose whatever best suit their needs.</p>
<p>Next, we'll go over a few of the most common relaying strategies.</p>
<h2 id="client-side-relaying"><a class="header" href="#client-side-relaying">Client-side Relaying</a></h2>
<p>Client-side relaying relies on the user-facing frontend, like a webpage or a wallet, to perform all three steps of the cross-chain process.</p>
<p>There are two major benefits of this approach:</p>
<ul>
<li>Low cost. Users pay exactly the transaction fee for the second transaction.</li>
<li>No backend relaying infrastructure.</li>
</ul>
<p>However, client-side relaying also has two notable drawbacks:</p>
<ul>
<li>Users must sign all transactions required with their own wallet.</li>
<li>Users must have funds to pay the transaction fees on every chain involved.</li>
</ul>
<p>Overall, client-side relaying is a simple solution, but can make the user experience cumbersome. It's generally not recommended if your goal is a highly-polished user experience but can be useful to getting an MVP up and running.</p>
<h2 id="specialized-relayers"><a class="header" href="#specialized-relayers">Specialized Relayers</a></h2>
<p>Specialized relayers solve the UX problems of client-side relayers by adding a backend component which can handle steps 2 and 3 on behalf of the user.</p>
<p>In this model, relayers either listen directly to the Guardian Network via a spy (called <strong>Spy Relaying</strong>), or will simply provide a REST endpoint to accept a VAA which should be relayed (called <strong>REST Relaying</strong>). Once a relayer has the VAA, it simply performs any necessary off-chain calculations and submits the VAA to the required destination.</p>
<p>An important consideration when developing a specialized relayer is that the relayer is still considered untrusted. VAAs are public and can be submitted by anyone, so developers should not rely on off-chain relayers to perform any computation which is considered &quot;trusted.&quot; However, things that do not impact security like deterministic data transforms, waiting for gas prices to drop, or various forms of 'batching' can be very useful cost-reduction strategies.</p>
<p>Specialized Relayers have the following advantages:</p>
<pre><code>- They simplify user experience
- They allow off-chain calculations to be performed in the relayer, reducing gas costs
- They are generally easy to develop
</code></pre>
<p>However, they also have a couple notable downsides</p>
<pre><code>- They add a backend relaying component which is responsible for liveness
- They can complicate fee-modeling, as relayers are responsible for paying target chain fees.
</code></pre>
<p>Due to specialized relayers being such a common solution, an extensible relayer (called the plugin relayer) has been provided in the main Wormhole repository. The plugin relayer stands up most of the requisite infrastructure for relaying, so that you only need to implement the logic which is specific to your application.</p>
<p>If you plan to develop a specialized relayer, consider starting from the plugin relayer <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/relayer">found here</a>.</p>
<!--
TODO link to plugin relayer once it has been merged down
-->
<p>Because relayers are responsible for liveness, they become another dependency component (similar to the frontend, blockchain nodes, blockchains, third party APIs, etc.) for the xDapp. If the relayers are all down, your application has an outage.</p>
<p>To mitigate this, multiple relayers can be run in order to provide redundancy either by (1) the xDapp team or (2) a decentralized network based off economic incentives. <em>However, creating a robust model for decentralized relaying is generally application-specific and complex.</em></p>
<p>Overall, Specialized Relayers add a backend component that is responsible for liveness, but can simplify the user experience. It's generally recommend if your goal is a highly-polished user experience and you want to have better control over message delivery.</p>
<h1 id="generic-relayers"><a class="header" href="#generic-relayers">Generic Relayers</a></h1>
<p><em>Note: this feature is not yet available in mainnet</em></p>
<p>Because relaying is such an integral component to xDapps, Wormhole has built a protocol which allows developers to utilize a decentralized network of untrusted relayers to deliver their messages, removing the specialized relayer as an infrastructure responsibility.</p>
<p>In order to utilize the generic relayer network, developers must request delivery from the Wormhole Relay Ecosystem Contract and must also implement a &quot;receiveRelay&quot; function in their contracts, which will be called by the relayer. Once a delivery has been requested, the VAA is guaranteed to be delivered within a certain timeframe. The specifics of this vary by blockchain and smart contract runtime.</p>
<p>Generic relayers have the following benefits:</p>
<pre><code>- They feature simplified UX
- There are no relayer infrastructure requirements for the developer
</code></pre>
<p>And potential downsides:</p>
<pre><code>- They require all calculations to be done on-chain
- They sometimes have less gas efficiency
- They may not be supported on all chains
</code></pre>
<p>Overall, Generic Relayers simplify both the developer and user experience. They're a great choice if they cover all your usecases.</p>
<hr />
<p>In the next section, we'll discuss the xAsset module, which allows xAssets to be created and moved freely around the ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xasset-layer"><a class="header" href="#xasset-layer">xAsset Layer</a></h1>
<p>There is a set of ecosystem contracts that provision Wormhole's xAsset layer which allow tokens to be bridged around the Wormhole Ecosystem in a <strong>path-independent</strong> fashion, and are easily composable with other functions in the Wormhole ecosystem.</p>
<p>This section provides a high-level overview of how to interact with two smart contract modules that implement xAssets: (1) Token Bridge module and (2) NFT Bridge Module.</p>
<p>If you're looking to interact with the Token Bridge directly from a typescript client or backend, you should start with the <a href="https://www.npmjs.com/package/@certusone/wormhole-sdk">Wormhole Typescript SDK</a>.</p>
<h2 id="creating-xassets"><a class="header" href="#creating-xassets">Creating xAssets</a></h2>
<p>xAssets always have an <strong>origin chain</strong>. This is where the token is initially minted via the standard of that chain (ERC-20, SPL, etc for tokens; ERC-721, Metaplex, etc for NFTs).</p>
<p>xAssets are all <strong>fungible</strong> with each other. This means the Wormhole-wrapped asset can be exchanged for the original asset or a wrapped asset from other chains.</p>
<p><strong>Tokens</strong></p>
<p>To convert tokens into an xAsset, an <strong>attestation</strong> must first be created. To create an attestation, simply call the <strong>attest</strong> function on the token bridge contract of the origin chain.</p>
<pre><code>function attestToken(
    address tokenAddress,
    uint32 nonce)
 returns (uint64 sequence)
</code></pre>
<p>The Guardian Network will then produce an <strong>attestation VAA</strong>, which can be retrieved using the sequence number returned by the attestToken function.</p>
<p>The attestation VAA must then be submitted to the <strong>createWrapped</strong> function of every other chain, referred to as <strong>foreign chains</strong> for this token.</p>
<pre><code>function createWrapped(
    bytes memory encodedVm)
returns (address token)
</code></pre>
<p>Calling this function will deploy a new contract for the token on the foreign chain, creating a <strong>Wormhole-Wrapped Token</strong>. The wrapped token will use the same symbol as the origin asset, and will append (Wormhole) to the end of the name.</p>
<p><strong>NFTs</strong></p>
<p>NFTs do not need need to be attested before they can be created into a xAsset.</p>
<h2 id="transferring-xassets"><a class="header" href="#transferring-xassets">Transferring xAssets</a></h2>
<p>Initiating xAsset transfers is a straightforward affair. Once the transfer is initiated, the Guardians will produce a transfer VAA when finality has been reached on the <strong>source chain</strong>. The VAA must then be relayed to the <strong>target chain</strong>.</p>
<p>All tokens managed by the Token Bridge are backed by the origin asset, allowing assets to be transferred in a path-independent fashion. Regardless of what chain the assets are passed to, a 'double-wrapped' asset will never be created for a single backing asset. Additionally, there are no liquidity limitations.</p>
<p><strong>Tokens</strong></p>
<pre><code>    function transferTokens(
        address token,
        uint256 amount,
        uint16 recipientChain,
        bytes32 recipient,
        uint256 arbiterFee,
        uint32 nonce) returns (uint64 sequence)
</code></pre>
<p><strong>NFTs</strong></p>
<pre><code>function transferNFT(
    address token,
    uint256 tokenID,
    uint16 recipientChain,
    bytes32 recipient,
    uint32 nonce) returns (uint64 sequence)
)
</code></pre>
<h2 id="contract-controlled-transfers"><a class="header" href="#contract-controlled-transfers">Contract-Controlled Transfers</a></h2>
<p>Basic transfers are intended to transfer xAssets from one wallet to another, whereas Contract Controlled Transfers (CCTs) are meant to transfer xAssets from one smart contract to another. If you're writing an xDapp, CCTs will likely be a large component.</p>
<p>CCTs allow xDapp contracts to easily perform simple xAsset transfers, but have two additional features:</p>
<ul>
<li>An arbitrary byte array can be appended to the transfer and can be used to easily pass additional information to the recipient contract.</li>
<li>The CCT VAA redeem can only be performed by the recipient contract, as opposed to basic transfers, which can be performed by any caller. This ensures that any additional operations which the contract wants to perform as part of the redeem transaction must be executed.</li>
</ul>
<hr />
<p>In the next section, we'll discuss Wormchain and some of the upcoming features it will enable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wormchain"><a class="header" href="#wormchain">Wormchain</a></h1>
<p>Wormchain is a purpose-built cosmos blockchain for the Wormhole ecosystem. It has two primary functions:</p>
<ol>
<li>Provide a public and auditable mechanism for users to interact with the Guardian Network.</li>
<li>Create a robust platform for on-chain infrastructure which would be infeasible to build elsewhere.</li>
</ol>
<p>Wormchain is built to provide things like:</p>
<pre><code>- Redundant security checks
- Governance
- Interactions with 'legacy' chains like Bitcoin
</code></pre>
<p>Wormchain is less relevant to xDapp developers than some other parts of the ecosystem, but it will become an increasingly important component as Wormhole matures and features are added. </p>
<hr />
<p>In the next section, we'll get into the key concepts that underpin xDapp design.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xdapp-design"><a class="header" href="#xdapp-design">xDapp Design</a></h1>
<p>Now that we've established the major concepts and components underlying xDapps, let's dive into the process of designing one. This chapter will guide you through the considerations you should make before developing an xDapp, including topics like network topology, protocol design and more.</p>
<p>By the end of this chapter, you will have all the tools you need to lay out a design for your xDapp and start building.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-considerations"><a class="header" href="#key-considerations">Key Considerations</a></h1>
<p>Before we get started, we should outline the key considerations that will shape your xDapp. Below, we'll show how each of the decisions you make about these key considerations can impact the structure of your application as a whole.</p>
<h3 id="why"><a class="header" href="#why">Why?</a></h3>
<p>The reason you're building an xDapp is the foremost consideration. Think about the <a href="dapps/architecture/../5_advantages.html">advantages</a> of cross-chain development -- which of these are most important to you? Are you building a brand new application and you want the widest reach? Are you trying to increase the performance of an existing Dapp? Are you interested in composing on top of protocols that only exist in certain ecosystems? Determining your key priorities will help you make better technical decisions and tradeoffs when designing your xDapp.</p>
<h3 id="target-ecosystems--languages"><a class="header" href="#target-ecosystems--languages">Target Ecosystems &amp; Languages</a></h3>
<p>Which blockchains do you intend to support? Because different blockchains utilize different virtual machines, supporting more blockchains often requires writing smart contracts in more than one language.</p>
<h3 id="data-flows"><a class="header" href="#data-flows">Data Flows</a></h3>
<p>Think about where your data originates and where it needs to go. Does all your data come from user-initiated transactions? Do you have governance messages that need to be emitted from a central governance contract? Do you have automated actions which need to happen periodically to synchronize your data? </p>
<h3 id="liquidity--tokens"><a class="header" href="#liquidity--tokens">Liquidity &amp; Tokens</a></h3>
<p>Not all xDapps deal with tokens, but many do. If your app is centered around tokens, you'll have to decide which tokens will be utilized, where liquidity is aggregated (or fractured), and how this liquidity can be best utilized across your application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystems"><a class="header" href="#ecosystems">Ecosystems</a></h1>
<p>At present, there are 6 ecosystems supported by Wormhole, though the number of supported ecosystems is always growing.</p>
<h3 id="evm"><a class="header" href="#evm">EVM</a></h3>
<p>EVM is the most popular ecosystem, and most xDapps will have some support for this platform. These contracts are written in Solidity -- a 'jack of all trades' style of computation environment. A common strategy for xDapps is to develop one single contract in Solidity, and then deploy that contract to all the supported EVM blockchains.</p>
<p>Example chains:</p>
<pre><code>- Ethereum
- Polygon
- BNB Chain
- Avalanche (C Chain)
- Aurora (Near Network)
- Karura (Polkadot Network)
- Acala (Polkadot Network)
- Celo
- Fantom
- Oasis (Emerald)
</code></pre>
<h3 id="solana"><a class="header" href="#solana">Solana</a></h3>
<p>Solana is characterized by its high transaction throughput, increased computation power and cheap data storage when compared to EVM environments. These contracts are written in Rust.</p>
<h3 id="cosmos"><a class="header" href="#cosmos">Cosmos</a></h3>
<p>Cosmos is a network of blockchains that share a common ecosystem. Cosmos is a general purpose environment, but excels in certain areas like application-specific blockchains and the use of Cosmos-wide standards via its sdk 'modules.' It uses CosmWasm for its smart contract runtime, which is based in Rust.</p>
<h3 id="algorand"><a class="header" href="#algorand">Algorand</a></h3>
<p>Algorand is a leading blockchain on the state proof front and repesents the bleeding edge of trustlessness. These contracts are written in Python.</p>
<h3 id="aptos"><a class="header" href="#aptos">Aptos</a></h3>
<p>Aptos is characterized by its optimisitic approach to computation parallelization to bring increased performance. These contracts are written in Move.</p>
<h3 id="near"><a class="header" href="#near">NEAR</a></h3>
<p>NEAR is characterized by its sharding technology that may allow for greater transaction capacity and security. These contracts are written in Rust.</p>
<h3 id="read-only-chains"><a class="header" href="#read-only-chains">Read-Only Chains</a></h3>
<p>Some chains in the Wormhole ecosystem are 'Read-Only.' These chains are able to verify messages emitted from other chains in the network, but are not able to emit messages themselves. For information about these chains, check the <a href="dapps/architecture/../../reference/contracts.html">contracts page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-design"><a class="header" href="#protocol-design">Protocol Design</a></h1>
<p>They key feature of Wormhole is bringing message passing to the world of blockchain, so it's worthwhile to take some inspiration from other areas of software development that are based on similar principles.</p>
<p>Much of the traditional web stack is based on distributed systems that rely on message passing to create interfaces and boundaries for disparate systems to work together. We can think of xDapps as web3 distributed systems founded on similar paradigms.</p>
<h2 id="protocol-first-design"><a class="header" href="#protocol-first-design">Protocol First Design</a></h2>
<p>Protocol first design is a design philosophy where you initially lay out your data types, message formats and supported operations into a well-defined protocol. This creates a solid protocol layer which can serve as the foundation for your application. This way, the code instantiating that protocol can be treated as an implementation detail when reasoning about the protocol itself.</p>
<p>At this stage in the design, you should also consider the incentive structures surrounding your protocol. What is the incentive for each party to engage? Are there economic attack vectors in your application which might jeopardize its security? Do certain market conditions result in perverse outcomes? </p>
<p>Depending on your goals, this stage of the process can be as simple as stating &quot;people will want my NFT&quot; or as difficult as designing an entire ecosystem with multiple competing interested parties. </p>
<p>Once you have a clear idea of your core product, incentives and users, you can begin to lay out your data model. From there, you can define your message types and operations.</p>
<h2 id="common-strategies-and-conventions"><a class="header" href="#common-strategies-and-conventions">Common Strategies and Conventions</a></h2>
<h3 id="address-space"><a class="header" href="#address-space">Address Space</a></h3>
<p>Because there are many different formats for addresses across the different supported blockchains, a compatibility format is necessary. Wormhole uses its own address format (generally referred to as Wormhole format) in order to solve this issue. These addresses correspond 1 to 1 with native addresses on each chain.</p>
<p>A Wormhole address is a tuple containing the 2 byte Wormhole chain ID and a 32 byte shim address, totalling 34 bytes.</p>
<p>Because EVM addresses are only 20 bytes in length, to convert this to a Wormhole address, the address is left-padded with zeros until it's length 32. To transmit as this as a single item, the Wormhole chain ID is usually appended to the front, resulting in a 34 byte address.</p>
<p>When dealing with addresses inside your messages, it's recommended to always convert to Wormhole format and transmit in that format. You will regularly encounter addresses in the Wormhole format when interacting with other parts of the ecosystem, and adopting the format in your protocol will enhance your forward compatibility as you add more chains.</p>
<h3 id="trusted-contract-network"><a class="header" href="#trusted-contract-network">Trusted Contract Network</a></h3>
<p>Typically, the first check performed when receiving a message is to validate that it originates from a trusted source. If your protocol has smart contracts deployed to multipe chains, it will be important for your contracts to know which other contracts are 'in network' for your protocol. </p>
<p>Generally, this list of trusted contracts is stored in the state of each contract individually. Updating the trusted contracts is tied into the governance mechanism of the protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topology"><a class="header" href="#topology">Topology</a></h1>
<p>Topology describes how data flows through your application and defines the responsibilities of each component. In terms of overall xDapp topology, the primary decision is determining where your smart contracts will live and the responsibilities each contract will hold.</p>
<h2 id="ultra-light-clients"><a class="header" href="#ultra-light-clients">Ultra-light Clients</a></h2>
<p><img src="dapps/architecture/../../diagrams/images/ultralight_2.png" alt="Ultra-light client" title="Ultra Light Clients" /></p>
<p>Ultra-light Clients are often the best option when designing an MVP for your xDapp. The defining feature of an Ultra-light Client is that you are able to support users from every chain in the Wormhole ecosystem while <strong>only having smart contracts on a single chain (!!!)</strong>.</p>
<p>xDapps with this structure work by having a hub chain that all application contract logic is deployed to and entrypoints which receive and send Wormhole messages to remote chains. The network of Wormhole contracts deployed on other chains across the ecosystem provide the rest of the heavy lifting to send messages across chains.</p>
<p>You can think of the data flow across a xDapp with a Ultra-light Client as follows:</p>
<ol>
<li>The end user's wallet interacts with Wormhole contracts on remote chain.</li>
<li>The Wormhole contracts on remote chain generate a VAA which is received by your xDapp contract on the hub chain.</li>
<li>Your xDapp contract on the hub chain performs all necessary operations.</li>
<li>Your xDapp contract interacts with Wormhole contracts on the hub chain.</li>
<li>The Wormhole contracts on hub chain generate a VAA which is sent back to the end user's wallet on the remote chain.</li>
</ol>
<p><strong><em>Advantages:</em></strong></p>
<ul>
<li>Very little added smart contract risk.</li>
<li>Simple to develop.</li>
<li>Easiest way to get heterogenous ecosystem support.</li>
</ul>
<p><strong><em>Disadvantages:</em></strong></p>
<ul>
<li>Latency: Transactions incur latencies associated with bridging into and out of both the remote and hub chain.</li>
<li>Transaction Fees: There are always a grand total of three transactions. Two on the remote chain, and one on the hub chain.</li>
<li>Use cases: There is no place to perform trusted computation on the remote chain, so some use cases are more difficult to implement (or potentially not possible).</li>
</ul>
<h2 id="hub-and-spoke"><a class="header" href="#hub-and-spoke">Hub-and-Spoke</a></h2>
<p><img src="dapps/architecture/../../diagrams/images/hub_and_spoke.PNG" alt="Hub and Spoke" title="Hub and Spoke" /></p>
<p>Hub and Spoke models can somewhat be thought of as the natural evolution of the ultra-light client. There is still a hub contract which handles all transactions, but there is now also a contract deployed to all the remote chains that is capable of performing some trusted computation.</p>
<p>You can think of the data flow across a Hub-and-Spoke system as follows:</p>
<ol>
<li>The end user's wallet interacts with your (lightweight) remote contracts.</li>
<li>The remote contracts perform any necessary trusted computation.</li>
<li>The remote contracts use Wormhole to generate a VAA, which is consumed by the hub contract.</li>
<li>The hub contract performs all necessary operations.</li>
<li>The hub contract uses Wormhole to send a message back to the original remote contract.</li>
<li>The remote contract takes whatever action is needed to finish the process.</li>
</ol>
<p><strong><em>Advantages:</em></strong></p>
<ul>
<li>Remote contracts are lightweight and don't carry large amounts of risk.</li>
<li>Can perform trusted checks on the remote chain. (Such as validating wallet balance, or any other piece of blockchain state)</li>
</ul>
<p><strong><em>Disadvantages:</em></strong></p>
<ul>
<li>Latency (same as ultra-light clients)</li>
<li>Transaction Fees</li>
<li>Managing multiple contracts</li>
</ul>
<h2 id="mesh"><a class="header" href="#mesh">Mesh</a></h2>
<p><img src="dapps/architecture/../../diagrams/images/mesh.PNG" alt="Mesh" title="Mesh" /></p>
<p>Mesh topologies can somewhat be thought of as the next evolution of the Hub and Spoke model. There are now contracts capable of handling all transactions for an application are deployed on all supported chains. Each contract can be thought of as a peer of other contracts in the trusted network and can act autonomously.</p>
<p>This is historically the most popular methodology for going cross-chain. It's very attractive in ecosystems like EVM or Cosmos, where a single smart contract can simply be deployed across many different blockchains.</p>
<p><strong><em>Advantages:</em></strong></p>
<ul>
<li>Latency: Users can often perform their operation without waiting for other chains.</li>
<li>Transaction Fees: Does not stack the transaction fees of multiple chains.</li>
</ul>
<p><strong><em>Disadvantages:</em></strong></p>
<ul>
<li>Complexity: there are now quite a few contracts to manage, especially if they are implemented multiple times across different VMs.</li>
<li>Data desync: because each blockchain acts independently, each chain will have independent state. This can open up unwanted arbitrage opportunities and other discrepancies.</li>
<li>Race conditions: In cases where an event is supposed to propagate through the entire system at a fixed time (for example, when closing a governance vote), it can be difficult to synchronize all the blockchains.</li>
</ul>
<h2 id="distributed"><a class="header" href="#distributed">Distributed</a></h2>
<p><img src="dapps/architecture/../../diagrams/images/distributed.PNG" alt="Distributed" title="Distributed" /></p>
<p>Distributed topologies can somewhat be thought of as the next evolution of the Mesh model. Instead of contracts that are capable of handling all transactions for an application on all supported chain, applications are broken up into separate responsibilities (i.e. data storage, user interaction, asset custody, governance) and deployed to different blockchains.</p>
<p>Advantages:</p>
<ul>
<li>Power: utilize each blockchain for whatever is most optimal.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Complexity: requires multiple specialized smart contracts, and potentially additional on-chain processes.</li>
</ul>
<h2 id="mix--match"><a class="header" href="#mix--match">Mix &amp; Match</a></h2>
<p>Different use cases have different optimal topologies, and it's possible to use different topologies for different workflows in your application. This means you should not feel 'locked in' to a single topology, and should instead consider designing each workflow independently. For example, governance workflows are generally best implemented using a Hub and Spoke topology, even if the rest of the application uses a Mesh architecture. As such, your contracts will likely evolve over time as your xDapp evolves and adds additional workflows.</p>
<p>You can also progress through different topologies. A common strategy is to start off with an ultra-light client, move to a hub and spoke configuration, and then add optimizations and specialties to contracts as the need arises.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayers-1"><a class="header" href="#relayers-1">Relayers</a></h1>
<p>In Chapter 2, we discussed the <a href="dapps/architecture/../../wormhole/6_relayers.html">general concepts associated with relayers in the Wormhole ecosystem</a>. In this section, we'll elaborate on the considerations that should be accounted for when using relayers in your xDapp.</p>
<h2 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h2>
<p>It's important to remember that relayers are untrusted. This means you don't have to trust them--but it also means you can't trust them. This is true of both generic and specialized relayers.</p>
<p>Let's dive into a little more detail about why relayers are untrusted and what this means for you.</p>
<p>A few key properties of VAAs:</p>
<ul>
<li>They are publicly emitted from the Guardian Network.</li>
<li>They need to be signed by the Guardian Network to be considered authentic.</li>
<li>They can be verified as authentic by anyone and any Wormhole Core Contract.</li>
</ul>
<p>Relayers are untrusted as an inherent consequence of these properties. Anyone can pick up a VAA and deliver it anywhere, but no one can alter the content of the VAA without invalidating the signatures.</p>
<p>So, when writing your contracts, it's incredibly important to only trust information which is either inside your contract or inside a VAA. If you trust information provided by a relayer, you are opening yourself up to untrusted input attacks.</p>
<p>The easiest and most secure way to interact with relayers then is to only accept the VAA as input. If the relayer can't provide any additional args, then there's no way for them to provide untrusted input.</p>
<p>More advanced strategies involve having the relayer perform untrusted off-chain computation which is passed into the destination contract. These strategies can optimize gas costs, but can also create attack vectors if not used correctly.</p>
<p>With this in mind, relayer design becomes a matter of structuring the messages in your protocol such that there is a single, deterministic way that they can be processed. In a well designed protocol, relayers have a 'correct' implementation.</p>
<p>Relayers are conceptually quite similar to &quot;crank turner&quot; processes used elsewhere in blockchain, in that there is only a single action which can be taken (pulling the crank), and their sole responsibility is to initiate this action and pay for the costs.</p>
<hr />
<h2 id="generic-relayers-1"><a class="header" href="#generic-relayers-1">Generic Relayers</a></h2>
<p>Generic relayers are a decentralized relayer network which can deliver arbitrary VAAs as long as the recipient contract conforms with the generic relayer API.</p>
<p><strong><em>Advantages:</em></strong></p>
<ul>
<li>Generic relayers are done purely on-chain, so there's no need to develop, host or maintain relayers.</li>
</ul>
<p><strong><em>Disadvantages:</em></strong></p>
<ul>
<li>There's less room for optimization via features like conditional delivery, batching, off-chain calculations, etc.</li>
</ul>
<hr />
<h2 id="specialized-relayers-1"><a class="header" href="#specialized-relayers-1">Specialized Relayers</a></h2>
<p>Specialized Relayers are relayers that are purpose-built to relay messages for a certain application. In the future, there may be ways to customize generic relayers such that they will gain the advantages of today's specialized relayers.</p>
<p><strong><em>Advantages:</em></strong></p>
<ul>
<li>Specialized relayers can perform off-chain untrusted computation.</li>
<li>They are highly customizeable and can perform batching, conditional delivery, multi-chain deliveries, etc.</li>
<li>Can home-roll an incentive structure.</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Requires development work and relayer hosting.</li>
</ul>
<hr />
<h3 id="relayer-incentives"><a class="header" href="#relayer-incentives">Relayer Incentives</a></h3>
<p>Relayers have to cover the costs of executing the downstream transactions resulting from the original 'source' transaction. Unless the relayers are running at a loss, there must be a mechanism for reimbursing the relayer in exchange for message delivery.</p>
<p>There are many strategies for reimbursement, and the 'best' strategy for an application is often dependent on the specifics of that application. However, a few of the most common strategies are:</p>
<ul>
<li>Pay the relayer with a potion of the tokens being sent cross-chain.</li>
<li>Collect a safe amount of gas money from the end user prior to performing any actions.</li>
<li>'Lazy' relaying, where relaying might only be profitable in certain, potentially rare, market conditions.</li>
</ul>
<p>Generic relayers have an incentive model built in to the network, so you do not need to design an incentive structure when using them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h1>
<p>The bare minimum Wormhole environment is just a blockchain linked up to a Guardian node. There are quite a few ways of accomplishing this, and if you're just looking to get your feet wet, you should try whichever sounds easiest.</p>
<p>However, as you get deeper into cross-chain development, you'll likely find yourself with a growing number of components, dependencies, and teammates in the picture making your development environment more complex. Here are some of the considerations you should have in mind when choosing a development environment which will be well suited for your xDapp.</p>
<h3 id="what-components-do-i-need-now-what-components-will-i-need-in-the-future"><a class="header" href="#what-components-do-i-need-now-what-components-will-i-need-in-the-future">What components do I need now? What components will I need in the future?</a></h3>
<ul>
<li>You may be able to get a lot done with just an EVM chain and a Guardian. However, as your application gets more sophisticated, components like relayers, frontends, automated tests, databases, explorers, and other blockchains are likely to get added into the environment.</li>
</ul>
<h3 id="what-are-my-dependencies"><a class="header" href="#what-are-my-dependencies">What are my dependencies?</a></h3>
<ul>
<li>
<p>If your smart contracts have no dependencies, it may be possible for you to develop in a vacuum.</p>
</li>
<li>
<p>If your smart contracts does have dependencies, there are several options that range from deploying your dependencies in <a href="technical/env/./tilt.html">Tilt</a> to simulating an existing testnet/mainnet in <a href="https://github.com/foundry-rs/foundry">Foundry</a> to working directly in <a href="technical/env/./testnet.html">testnet</a> alongside other teams.</p>
</li>
</ul>
<h3 id="how-am-i-going-to-collaborate"><a class="header" href="#how-am-i-going-to-collaborate">How am I going to collaborate?</a></h3>
<ul>
<li>You should consider how your teammates or collaborators are going to work in this environment from the start. There are some basic considerations like &quot;how will they access it&quot;, but also some subtler points such as ensuring that contracts will deploy deterministically and that automated tests can be trusted to run reliably. The two paths to accomplish this are to use a public environment (testnet), or to ensure the local environment is well controlled (like tilt).</li>
</ul>
<hr />
<p>In the following sections we'll describe three different development environments that are available -- Tilt, Wormhole Local Validator, and Testnet -- in more details as well as some additional tools that should be helpful in your xDapp development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tilt-devnet"><a class="header" href="#tilt-devnet">Tilt (Devnet)</a></h1>
<h2 id="what-is-tilt"><a class="header" href="#what-is-tilt">What is Tilt?</a></h2>
<p><a href="https://tilt.dev/">Tilt</a> is part of the official Docker ecosystem. It's a tool which allows developers to easily configure a Kubernetes environment for development.</p>
<p>However, in the context of Wormhole, 'Tilt' refers to the development environment used by the <a href="https://github.com/wormhole-foundation/wormhole">Wormhole Core Repository</a>. This environment stands up docker images for all the tools necessary to build across multiple blockchains, including:</p>
<ul>
<li>All the Wormhole supported blockchains / ecosystems</li>
<li>A Guardian Node</li>
<li>Relayers</li>
<li>Databases, Redis</li>
<li>Utility frontends</li>
</ul>
<p>The 'Tilt' environment is meant to provide an entire cross-chain development stack right out of the box.</p>
<p><em>Note: Tilt is often referred to as 'Devnet' in the Wormhole ecosystem so any information that is labelled as 'devnet' also applies to Tilt.</em></p>
<h3 id="is-tilt-right-for-you"><a class="header" href="#is-tilt-right-for-you">Is Tilt Right for You?</a></h3>
<p>Tilt is generally a good starting point for most developers. Here's a succinct list of the pros and cons of the environment, so you can decide if it's the right fit for you.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Out-of-the-box support for the many components needed to develop across the heterogenous blockchain spaces.</li>
<li>Consistent development environment, where contracts deploy deterministically and everything is already linked up.</li>
<li>Ability to easily enable/disable components as needed.</li>
<li>Regularly updated as new components join the Wormhole ecosystem.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Relatively high system requirements but this can be mitigated by disabling components.</li>
<li>Most blockchains are 'fresh' and have no contracts by default. Thus, if your contracts have any dependencies, you may have to deploy them yourself or alter the default tilt configuration.</li>
<li>Spin-up and rebuild times can be slow which can result in a slow workflow.</li>
</ul>
<h2 id="setting-up-tilt"><a class="header" href="#setting-up-tilt">Setting up Tilt</a></h2>
<p>Tilt functions best in a UNIX-style environment. For Windows users, a WSL environment is recommended.</p>
<p>In order to run the Tilt environment, make sure you have <a href="https://docs.tilt.dev/install.html">Tilt</a> and <a href="https://go.dev/doc/install">Go</a> installed.</p>
<p>Once you've installed these two dependencies, just clone the Wormhole Core Repository and start Tilt.</p>
<pre><code>git clone --branch dev.v2 https://github.com/wormhole-foundation/wormhole.git

cd wormhole

tilt up
</code></pre>
<p>Be sure to check out the <a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/Tiltfile"><strong>Tiltfile</strong></a>, which has much of the configuration and arguments for the development environment. It's relatively straightforward to enable and disable components. </p>
<p>For example, you can disable blockchains by setting them to false at startup</p>
<pre><code>tilt up -- --algorand=false --near=false --solana=false terra_classic=false terra2=false
</code></pre>
<h2 id="using-tilt"><a class="header" href="#using-tilt">Using Tilt</a></h2>
<p>Tilt can pretty much be treated as an external environment / testnet that you can easily spin up and tear down.</p>
<p>If you've followed the standard setup, all your resources will be bound to various ports on localhost. To see all the endpoints which are being hosted in your Tilt environment, you should check the Tilt dashboard, located at <a href="http://localhost:10350/overview">http://localhost:10350/overview</a>.</p>
<p>All the deployed contract addresses can be found under the 'Devnet / Tilt' section of <a href="technical/env/../../reference/contracts.html">contracts</a>.</p>
<p>Useful information pertaining to funded wallets &amp; private keys can also be found in the <a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/docs/devnet.md">devnet.md</a> file of the docs.</p>
<p>Additional helpful resources can be found in the <a href="technical/env/./tooling.html">Tooling</a> page.</p>
<h2 id="shutting-down-tilt"><a class="header" href="#shutting-down-tilt">Shutting down Tilt</a></h2>
<p>In order to shut down Tilt, simply run</p>
<pre><code>tilt down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>Tilt, Kubernetes, and Docker may be new tools for developers entering the Wormhole ecosystem. This section is meant to provide some additional support when setting up the Wormhole Tilt environment.</p>
<h1 id="macos-install"><a class="header" href="#macos-install">macOS Install</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Install <a href="https://brew.sh">Homebrew</a> if you don't already have it.</p>
<p>You can grab it with:</p>
<pre><code class="language-sh">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<p>From there, all the other installs are one-liners.</p>
<h3 id="1-install-go"><a class="header" href="#1-install-go">1. Install Go</a></h3>
<pre><code class="language-sh">brew install go
</code></pre>
<h3 id="2-install-docker"><a class="header" href="#2-install-docker">2. Install Docker</a></h3>
<pre><code class="language-sh">brew install docker
</code></pre>
<p>After installation, go into Docker settings and switch ON <code>kubernetes</code>. Also configure Docker to have 4 CPUs and ~16GB of RAM.</p>
<h3 id="3-install-tilt"><a class="header" href="#3-install-tilt">3. Install Tilt</a></h3>
<pre><code class="language-sh">brew install tilt
</code></pre>
<h3 id="4-clone-wormhole-repo-and-start-tilt"><a class="header" href="#4-clone-wormhole-repo-and-start-tilt">4. Clone Wormhole Repo and Start Tilt</a></h3>
<pre><code class="language-sh">git clone --branch dev.v2 https://github.com/wormhole-foundation/wormhole.git
cd wormhole/
tilt up
</code></pre>
<p>You'll be able to access the Tilt UI at
<code>localhost:10350</code></p>
<h1 id="linux--wsl-install"><a class="header" href="#linux--wsl-install">Linux &amp; WSL Install</a></h1>
<h2 id="script-setup"><a class="header" href="#script-setup">Script Setup</a></h2>
<p>If you're using a Debian distro, you should run the <a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/scripts/dev-setup.sh">dev-setup.sh</a> script. Even if you're not using Debian, this script still contains the main steps for setup.</p>
<h2 id="regular-setup"><a class="header" href="#regular-setup">Regular Setup</a></h2>
<h3 id="1-install-go-1"><a class="header" href="#1-install-go-1">1. Install Go</a></h3>
<pre><code class="language-sh">wget https://go.dev/dl/go1.18.1.linux-amd64.tar.gz
rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.18.1.linux-amd64.tar.gz
</code></pre>
<h3 id="2-install-docker-1"><a class="header" href="#2-install-docker-1">2. Install Docker</a></h3>
<p>If you're using Linux with a window manager, consider getting Docker Desktop instead of the following command. It comes with Kubernetes built in and you won't need to download <code>minikube</code>. It's recommended to have at least 4 CPUs and 16GB RAM dedicated to Docker.</p>
<p>Also, make absolutely sure that you set up Docker as a non-root user.</p>
<p><a href="https://docs.docker.com/engine/install/ubuntu/#installation-methods">https://docs.docker.com/engine/install/ubuntu/#installation-methods</a></p>
<h3 id="3a-docker-desktop-install"><a class="header" href="#3a-docker-desktop-install">3a. (Docker Desktop Install)</a></h3>
<p>Enable Kubernetes by going into Settings &gt; Kubernetes</p>
<h3 id="3b-non-docker-desktop"><a class="header" href="#3b-non-docker-desktop">3b. (Non Docker Desktop)</a></h3>
<p>Install <a href="https://minikube.sigs.k8s.io/docs/start/"><code>minikube</code></a>.</p>
<p>Configure minikube:</p>
<pre><code>minikube start --driver=docker --kubernetes-version=v1.23.3 --cpus=4 --memory=14G --disk-size=10G --namespace=wormhole
</code></pre>
<p>Minikube needs to be running for tilt to work, so always make sure to run <code>minikube start</code> before you bring up tilt.</p>
<h3 id="4-install-tilt"><a class="header" href="#4-install-tilt">4. Install Tilt</a></h3>
<p>Install Tilt by copy pasting this into the Terminal:</p>
<pre><code class="language-sh">curl -fsSL https://raw.githubusercontent.com/tilt-dev/tilt/master/scripts/install.sh | bash
</code></pre>
<h3 id="5-clone-the-wormhole-repo-and-start-tilt"><a class="header" href="#5-clone-the-wormhole-repo-and-start-tilt">5. Clone the Wormhole Repo and start Tilt</a></h3>
<pre><code class="language-sh">git clone --branch dev.v2 https://github.com/wormhole-foundation/wormhole.git
</code></pre>
<p>If you're running Tilt on your machine:</p>
<pre><code class="language-sh">cd wormhole/
tilt up
</code></pre>
<p>If you're running Tilt in a VM, you'll need to pass in some extra flags to enable Tilt to listen to incoming traffic from external addresses:</p>
<pre><code class="language-sh">cd wormhole
tilt up --host=0.0.0.0 -- --webHost=0.0.0.0
</code></pre>
<p>You can now access the Tilt UI at either <code>localhost:10350</code> or <code>vm_external_ip:10350</code>.</p>
<p>If the VM's external IP doesn't work, check firewall and port settings to make sure your VM allows incoming traffic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wormhole-local-validator"><a class="header" href="#wormhole-local-validator">Wormhole Local Validator</a></h1>
<h2 id="what-is-wormhole-local-validator-wlv"><a class="header" href="#what-is-wormhole-local-validator-wlv">What is Wormhole Local Validator (WLV)?</a></h2>
<p><a href="https://github.com/wormhole-foundation/xdapp-book/tree/main/projects/wormhole-local-validator">Wormhole Local Validator</a> is meant to be the simplest custom environment. It consists only of a dockerized Guardian image, and some utility tooling to aid with contract management. This allows you to set it up with any blockchain you'd like.</p>
<h3 id="is-wlv-right-for-you"><a class="header" href="#is-wlv-right-for-you">Is WLV Right for You?</a></h3>
<p>Here's a succinct list of the pros and cons of the environment, so you can decide if it's the right fit for you.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Lightweight, low system resource demand.</li>
<li>Fast iteration times.</li>
<li>Can be added into an existing blockchain development setup.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>You may end up reinventing the tilt/testnet environment as you add more components.</li>
</ul>
<h2 id="setting-up-wormhole-local-validator"><a class="header" href="#setting-up-wormhole-local-validator">Setting up Wormhole Local Validator</a></h2>
<p>You will need Docker running in order to set up WLV. If you're on desktop, <a href="https://docs.docker.com/get-docker/">Docker Desktop</a> is generally the best choice, though <a href="https://docs.docker.com/engine/">Docker Engine</a> works fine too.</p>
<p>From there, you just need nodes for the blockchains you're interested in developing on. There is code to spin up EVM and Solana local validators included in the WLV project repo, as well as scripts to deploy the necessary Wormhole contracts to your local instances.</p>
<p>Further information can be found in the project's <a href="https://github.com/wormhole-foundation/xdapp-book/blob/main/projects/wormhole-local-validator/README.md">README</a>.</p>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<p>Q: Anvil isn't working</p>
<ul>
<li>While Foundry's 'forge' tool is the generally recommended tool for EVM contract compilation, Anvil isn't currently compatible with guardiand. Anvil reports block headers in a way which is non-compliant with go-ethereum, which means the guardian node can't correctly read anvil headers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnet"><a class="header" href="#testnet">Testnet</a></h1>
<p>Wormhole testnet is spread across many of the most popular testnet blockchains.</p>
<h3 id="is-testnet-right-for-you"><a class="header" href="#is-testnet-right-for-you">Is Testnet right for you?</a></h3>
<p>The primary reason to use Wormhole testnet is to simplify the management of your dependent contracts. This will vary from blockchain to blockchain.</p>
<p>For example, some blockchain ecosystems have the standard that their contracts are closed-source, and there are no tools to fork mainnet. Other ecosystems, such as EVM, have tools like <a href="https://github.com/foundry-rs/foundry">foundry</a>, which allow you to hardfork the mainnet ecosystem into a local development node.</p>
<p>In short, testnet tends to be the correct choice only when you have contract dependencies, and those dependencies are difficult to get working in a local environment. In most other cases, testnet tends to be more work than it's worth.</p>
<p>Here's a succinct list of the pros and cons of the environment, so you can decide if it's the right fit for you.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Many other projects deploy their contracts to testnet.</li>
<li>In ecosystems without extensive local tooling, this may be the preferred development environment.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Many testnets are somewhat unstable and have outages or partitioning events.</li>
<li>Wormhole Testnet sometimes misses VAAs due to testnet instabilities.</li>
<li>Testnet tokens are often difficult to acquire.</li>
</ul>
<h2 id="using-testnet"><a class="header" href="#using-testnet">Using Testnet</a></h2>
<p>If you elect to use testnet, the Wormhole contracts addresses can be found in the <a href="technical/env/../../reference/contracts.html">Contracts</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<p>Regardless of the development environment that you use, there are a few wormhole-specific tools you should know about.</p>
<h3 id="wormhole-core-repository"><a class="header" href="#wormhole-core-repository"><a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/">Wormhole Core Repository</a></a></h3>
<ul>
<li>Most developers find it useful to clone the Wormhole Core repository. This repository provides the Devnet Tilt environment, plenty of useful code examples and tests, along with some utilities which do not have an official release package.</li>
</ul>
<h3 id="worm-cli-tool"><a class="header" href="#worm-cli-tool"><a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/clients/js">Worm CLI tool</a></a></h3>
<ul>
<li>Swiss-Army Knife Utility CLI tool. Excellent for creating one-off VAAs, parsing VAAs, reading Wormhole contract configurations, and more.</li>
</ul>
<h3 id="orchestrator"><a class="header" href="#orchestrator"><a href="https://github.com/wormhole-foundation/xdapp-book/blob/main/projects/evm-messenger/orchestrator.js">Orchestrator</a></a></h3>
<ul>
<li>Small WIP tool which comes as part of the <a href="technical/env/./wlv.html">Wormhole Local Validator</a> environment. Used to quickly deploy and redeploy multiple smart contracts. Will eventually become part of a larger deployment management tool.</li>
</ul>
<h3 id="wormhole-sdks"><a class="header" href="#wormhole-sdks"><a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk">Wormhole SDKs</a></a></h3>
<ul>
<li>Libraries in various languages to help with interacting with Wormhole contracts.</li>
</ul>
<h3 id="wormhole-typescript-sdk"><a class="header" href="#wormhole-typescript-sdk"><a href="https://www.npmjs.com/package/@certusone/wormhole-sdk">Wormhole Typescript SDK</a></a></h3>
<ul>
<li>Typescript SDK destributed on npm. Can greatly aid in writing frontend code for xDapps and utilizing the Wormhole Token Bridge directly.</li>
</ul>
<h3 id="wormhole-spy-sdk"><a class="header" href="#wormhole-spy-sdk"><a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/spydk/js">Wormhole Spy SDK</a></a></h3>
<ul>
<li>The Wormhole Spy SDK allows you to listen to all of the activity on the Guardian Network.</li>
</ul>
<h3 id="reference-bridge-ui"><a class="header" href="#reference-bridge-ui"><a href="https://github.com/wormhole-foundation/example-token-bridge-ui">Reference Bridge UI</a></a></h3>
<ul>
<li>An example GUI which can be used to perform token transfers around the ecosystem.</li>
</ul>
<h3 id="explorer"><a class="header" href="#explorer"><a href="https://wormhole.com/explorer/">Explorer</a></a></h3>
<ul>
<li>Resource for looking at individual transfers statuses on mainnet and testnet.</li>
</ul>
<!--
how to use on tilt?
-->
<!--
Example projects
-->
<h2 id="example-projects"><a class="header" href="#example-projects">Example Projects</a></h2>
<h3 id="basic-examples"><a class="header" href="#basic-examples"><a href="https://github.com/wormhole-foundation/xdapp-book/tree/main/projects">Basic Examples</a></a></h3>
<ul>
<li>Several example projects are bundled here. They show minimum-code examples for how to send messages, tokens, and other common functions.</li>
</ul>
<h3 id="icco"><a class="header" href="#icco"><a href="https://github.com/certusone/wormhole-icco">ICCO</a></a></h3>
<ul>
<li>Productionized, audited xDapp which does cross-chain token launches. Great example of what a robust xDapp, written across multiple ecosystems looks like.</li>
</ul>
<h3 id="native-swap"><a class="header" href="#native-swap"><a href="https://github.com/certusone/wormhole-nativeswap-example">Native Swap</a></a></h3>
<ul>
<li>Example cross-chain dex, utilizing the stablecoin highway model.</li>
</ul>
<h3 id="wormhole-examples"><a class="header" href="#wormhole-examples"><a href="https://github.com/certusone/wormhole-examples">Wormhole Examples</a></a></h3>
<ul>
<li>More example components. Has a mix of relayers, xDapps, NFT projects, and more.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-development"><a class="header" href="#contract-development">Contract Development</a></h1>
<p>This section should help you get off the ground with contract development in the Wormhole ecosystem.</p>
<p>It is written in a fashion which assumes familiarity with smart contract development in each ecosystem. As such, it doesn't provide information on smart contract basics, and instead focuses on how to properly interact with the provided Wormhole functions.</p>
<p>While the syntax for each programming environment differs, the general structure of the code and best practices tend to be quite similar. You should consider referencing the sections for environments other than the one you're working in, as many of the concepts outlined here are universal to cross-chain development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-1"><a class="header" href="#evm-1">EVM</a></h1>
<p><strong>Disclaimer</strong>: This section is written as a guide for how to use Wormhole for experienced EVM developers. If you are new to using the EVM ecosystem, it's recommended for you to get started with a tutorial like <a href="https://ethereum.org/en/developers/docs/intro-to-ethereum/">this</a>.</p>
<p>Within the Wormhole ecosystem, EVM refers to any blockchain that utilizes EVM contracts of Wormhole -- this includes blockchains beyond Ethereum such as Polygon or Avalanche, as well as EVM+ environments such as Acala.</p>
<p>At certain points, it may be easiest to integrate simply by referencing the implementation of the Wormhole contracts. The official implementation for the Wormhole contracts can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/ethereum">here</a>.</p>
<h3 id="recommended-tooling-for-evm"><a class="header" href="#recommended-tooling-for-evm">Recommended Tooling for EVM</a></h3>
<p><strong>Frontend Development</strong></p>
<ul>
<li><a href="https://docs.ethers.io/v5/">Ethers</a> an excellent, widely used library for using web-based wallets to interact with EVM blockchains.</li>
</ul>
<p><strong>Contract Development and Testing</strong></p>
<ul>
<li><a href="https://github.com/foundry-rs/foundry">Foundry</a> is the preferred library for the Core Repository. It has tooling for development, testing, compilation, and even the ability to duplicate mainnet environments for development.</li>
<li><a href="https://trufflesuite.com/">Truffle</a> and <a href="https://hardhat.org/">Hardhat</a> are also viable alternatives.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-message-layer"><a class="header" href="#core-message-layer">Core Message Layer</a></h1>
<p>This section will explain how to properly interact with the Wormhome Core Message Layer in an EVM ecosystem.</p>
<p>Messages in Wormhole take the form of a Verified Action Approval (VAA) and both terms can be used interchangably. The rest of this section will only use the term VAA.</p>
<h2 id="configuring-the-interface"><a class="header" href="#configuring-the-interface">Configuring the Interface</a></h2>
<p><a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/ethereum/contracts/interfaces">Here</a> is the interface for applications to interact with Wormhole's Core Contract to publish VAAs or verify and parse a received VAAs.</p>
<p>Instantiating the interface will depend on the contract address of your development ecosystem and blockchain.</p>
<p>Below is an example line of code to instantiate the interface for mainnet Ethereum:</p>
<pre><code>address private wormhole_core_bridge_address = address(0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B);
IWormhole core_bridge = IWormhole(wormhole_core_bridge_address);
</code></pre>
<h2 id="primary-functions"><a class="header" href="#primary-functions">Primary functions</a></h2>
<p>The Wormhole Core Layer has two important interactions -- (1) emit VAAs, and (2) parse and verify VAAs that originated from other chains.</p>
<h3 id="emitting-a-vaa"><a class="header" href="#emitting-a-vaa">Emitting a VAA</a></h3>
<p>There are two forms of VAAs that can be emitted:</p>
<ul>
<li>Single VAA: all messages will be emitted in this format</li>
<li>Batch VAA: messages that are generated from the same transaction will be emitted in this format. This feature was developed to provide an easier paradigm for composability and better gas efficiency for more involved cross-chain activity.</li>
</ul>
<p>To emit a VAA, always use <code>publishMessage</code> which takes in the following arguments:</p>
<ol>
<li><code>nonce</code> (uint32): a number assigned to each message
<ul>
<li>The <code>nonce</code> provides a mechanism by which to group messages together within a Batch VAA. How the <code>nonce</code> is used is described below.</li>
</ul>
</li>
<li><code>Consistency</code> (uint8): the number of blocks that Guardians will wait before signing a message
<ul>
<li>Each blockchain has different finality periods based on the consensus mechanism. In general, higher consistency values provides more security against blockchain reorgs. <a href="technical/evm/../../reference/contracts.html">Here</a> are the consistency levels by blockchain that are used by the xAsset layer to have a high level of guarantee against reorgs.</li>
</ul>
</li>
<li><code>Payload</code> (bytes[]): raw bytes to emit
<ul>
<li>It is up to the emitting contract to properly define this arbitrary set of bytes.</li>
</ul>
</li>
</ol>
<p><code>publishMessage</code> will output a <code>sequence</code> (uint64) that is used in conjunction with <code>emitterChainID</code> and <code>emitterAddress</code> to retrive the generated VAA from the Guardian Network.</p>
<blockquote>
<p>How Batch VAAs are generated</p>
<p>There are two mechanisms that allow messages to be Batched together that represent a base and more advanced level of composability.</p>
<ol>
<li>All messages originating from the same transaction will be batched together.</li>
<li>Messages that originate from the same transaction and are assigned the same nonce are additionally batched together.</li>
</ol>
<p><em>Note: Single VAAs will always be emitted for each message within a transaction, regardless of if a message is included in a batch or not.</em></p>
<p>Here is an example of how messages generated from the same transaction may be batched together:</p>
<p>A transaction X that generates 6 messages [A, B, C, D, E, F] that are assigned <code>nonce</code> [1, 2, 2, 3, 3, 4] respectively will generate the following VAAs:</p>
<ul>
<li>(1) full transaction batch VAA
<ul>
<li>[A, B, C, D, E, F]</li>
</ul>
</li>
<li>(2) smaller batch VAA
<ul>
<li>[B, C]</li>
<li>[D, E]</li>
</ul>
</li>
<li>(6) single VAA
<ul>
<li>[A]</li>
<li>[B]</li>
<li>[C]</li>
<li>[D]</li>
<li>[E]</li>
<li>[F]</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="parsing-and-verifying-a-vaa"><a class="header" href="#parsing-and-verifying-a-vaa">Parsing and Verifying a VAA</a></h3>
<p>Parsing and Verifying a VAA will depend on the type of VAA that your application expects: a Single VAA or a Batch VAA.</p>
<p>For either VAA type, remember to collect gas fees associated with submitting them on-chain after all VAAs have been verified.</p>
<p><strong>Single VAA</strong></p>
<p>To properly parse and verify a single VAA, always use <code>parseAndVerifyVM</code> which takes in one argument: <code>encodedVM</code> (bytes). This function will return three arguments:</p>
<ol>
<li><code>vm</code> (VM): Structured data that reflects the content of the VAA.
<ul>
<li>A breakdown of this message format is described in the <a href="technical/evm/../../wormhole/4_vaa.html">VAA</a> section. Aside from the header information, which can be considered 'trusted', it is up to the recipient contract to properly parse the remaining payload, as this contains the verbatim message sent from the emitting contract.</li>
</ul>
</li>
<li><code>valid</code> (bool): Boolean that reflects whether or not the VAA was properly signed by the Guardian Network</li>
<li><code>reason</code> (string): Explanatory error message if a VAA is invalid, or an empty string if it is valid.</li>
</ol>
<p><strong>Batch VAA</strong></p>
<p>To properly parse and verify a batch VAA, always use <code>parseAndVerifyBatchVM</code> which takes in two arguments: <code>encodedVM</code> (bytes) and <code>cache</code> (bool).</p>
<p>In most scenarios, you'll want to set <code>cache</code> equal to true.</p>
<p>This will return a VM2 object, containing all the 'headless' VAAs contained inside the batch VAA. These headless VAAs can be verified by <code>parseAndVerifyVM</code>, which means that modules which verify messages in an xDapp can be agnostic as to whether a message came from a batch VAA or a single VAA. </p>
<p>The <a href="technical/evm/./bestPractices.html">Best Practices</a> section goes into more depth of how to interact with the coreLayer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-bridge"><a class="header" href="#token-bridge">Token Bridge</a></h1>
<p>This section will explain how to properly interact with the Wormhome Token Bridge Module in an EVM ecosystem.</p>
<h2 id="configuring-the-interface-1"><a class="header" href="#configuring-the-interface-1">Configuring the interface</a></h2>
<p><a href="https://github.com/wormhole-foundation/wormhole/tree/wonge97/evm-interface/ethereum/contracts/bridge/interfaces">Here</a> is the interface for applications to interact with Wormhole's Token Bridge.</p>
<p>Instantiating the interface will depend on your development ecosystem and blockchain. The Wormhole Token Bridge contract address is usually stored in your contract address.</p>
<p>Below is an example line of code to instantiate the interface for mainnet Ethereum:</p>
<pre><code>address private wormhole_token_bridge_address = address(0x3ee18B2214AFF97000D974cf647E7C347E8fa585);
ITokenBridge token_bridge = ITokenBridge(wormhole_token_bridge_address);
</code></pre>
<h2 id="registering-new-tokens"><a class="header" href="#registering-new-tokens">Registering New Tokens</a></h2>
<p>Attesting a token from EVM needs to happen once per token as it will not be claimable until so. However, there are no restrictions to reattesting a token; repeat attestations will update the metadata.</p>
<p>It is not advised to attest tokens on-chain for most usecases. To attest a token by an off-chain process, you can either do it by hand through one of the Token Bridge UIs (for example <a href="https://www.portalbridge.com/#/register">Portal</a>) or using the <a href="https://www.npmjs.com/package/@certusone/wormhole-sdk">Typescript SDK</a>.</p>
<p><em><a href="technical/evm/../../development/portal/evm/attestingToken.html">Here</a> is an example of how to attest a token using the Typescript SDK.</em></p>
<h2 id="basic-transfer"><a class="header" href="#basic-transfer">Basic Transfer</a></h2>
<p>Basic transfer should only be used if you are transferring tokens to an end user wallet. If the end destination is a contract, you should only use Contract Controlled Transfers (described below).</p>
<p>It is important to note the transferring native currency is a special case of the Basic Transfer. As such, a different function call for initiating and completing a transfer is provided as a QoL improvement that will handle the wrapping and unwrapping of ETH.</p>
<p>To transfer a token, there are four steps:</p>
<ol>
<li>Approve the Token Bridge to spend that token on our behalf.
<ul>
<li><em>Note: Tokens in EVM usually denote up to 18 decimals places. However. Wormhole normalizes this to <strong>8</strong> decimals.</em></li>
</ul>
</li>
</ol>
<pre><code>contractAddress.approve(token_bridge_address, amt);
</code></pre>
<ol start="2">
<li>Transfer the token to create the transfer VAA.
<ul>
<li>This function call will return a <code>sequence</code> (uint64) that is used in the VAA retrieval step.</li>
<li><em>Note: For the recipient address, Wormhole addresses are 32 bytes for standardization across the different blockchains within the Wormhole ecosystem.</em></li>
</ul>
</li>
</ol>
<pre><code>// To initiate transfer of normal ERC-20s
token_bridge.transferTokens(tokenAddress, amount, recipientChain, recipient, arbiterFee, nonce);

// To initiate transfer of native currency
token_bridge.wrapAndTransferETH(recipientChain, recipient, arbiterFee, nonce);
</code></pre>
<ol start="3">
<li>Retrieve the emitted VAA.
<ul>
<li>Basic Transfer VAAs are retrieved from the Guardian Network by the <code>emitterChainID</code>, <code>emitterAddress</code>, and <code>sequence</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-js">const emitterAddr = getEmitterAddressEth(network.tokenBridgeAddress);
const seq = parseSequenceFromLogEth(tx, network.bridgeAddress);
const vaaURL = `${config.wormhole.restAddress}/v1/signed_vaa/${network.wormholeChainId}/${emitterAddr}/${seq}`;
let vaaBytes = await (await fetch(vaaURL)).json();
while (!vaaBytes.vaaBytes) {
  console.log(&quot;VAA not found, retrying in 5s!&quot;);
  await new Promise((r) =&gt; setTimeout(r, 5000)); //Timeout to let Guardiand pick up log and have VAA ready
  vaaBytes = await (await fetch(vaaURL)).json();
}
</code></pre>
<ol start="4">
<li>Complete the transfer using the VAA.</li>
</ol>
<pre><code>// To complete transfer of normal ERC-20s
token_bridge.completeTransfer(VAA);

// To complete transfer of native currency
completeTransferAndUnwrapETH(VAA);
</code></pre>
<h2 id="contract-controlled-transfer"><a class="header" href="#contract-controlled-transfer">Contract Controlled Transfer</a></h2>
<p>For any token transfers where the destination is a contract, you should always use Contract Controlled Transfers.</p>
<p>There are a few main differences between Contract Controlled Transfers and Basic Transfers:</p>
<ul>
<li>messages contains both tokens and an arbitrary payload</li>
<li>messages can only be redeemed by a specified contract address</li>
<li>messages do not have a relayer fee field because of the redemption restriction above</li>
</ul>
<p>As was the case with Basic Transfers, transferring native currency is a special case for Contract Controlled Transfers as well. As such, similar QoL improvement functions are provided that handle the wrapping and unwrapping of ETH.</p>
<p>The process of sending a Contract Controlled Transfer is very similar to that of a Basic Transfer:</p>
<ol>
<li>Approve the Token Bridge to spend that token on our behalf.
<ul>
<li><em>Note: Tokens in EVM usually denote up to 18 decimals places. However. Wormhole normalizes this to <strong>8</strong> decimals.</em></li>
</ul>
</li>
</ol>
<pre><code>contractAddress.approve(token_bridge_address, amt);
</code></pre>
<ol start="2">
<li>Transfer the token to create the transfer VAA.
<ul>
<li>This function call will return a <code>sequence</code> (uint64) that is used in the VAA retrieval step.</li>
<li><em>Note: For the recipient addres, Wormhole addresses are 32 bytes for standardization across the different blockchains within the Wormhole ecosystem.</em></li>
</ul>
</li>
</ol>
<pre><code>// To initiate transfer of normal ERC-20s
token_bridge.transferTokesWithPayload(tokenAddress, amount, recipientChain, recipient, nonce, payload);

// To initiate transfer of native currency
token_bridge.wrapAndTransferETHWithPayload(recipientChain, recipient, nonce, payload);
</code></pre>
<ol start="3">
<li>Retrieve the emitted VAA.
<ul>
<li>Contract Controlled Transfer VAAs are retrieved from the Guardian Network by the <code>emitterChainID</code>, <code>emitterAddress</code>, and <code>sequence</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-js">const emitterAddr = getEmitterAddressEth(network.tokenBridgeAddress);
const seq = parseSequenceFromLogEth(tx, network.bridgeAddress);
const vaaURL = `${config.wormhole.restAddress}/v1/signed_vaa/${network.wormholeChainId}/${emitterAddr}/${seq}`;
let vaaBytes = await (await fetch(vaaURL)).json();
while (!vaaBytes.vaaBytes) {
  console.log(&quot;VAA not found, retrying in 5s!&quot;);
  await new Promise((r) =&gt; setTimeout(r, 5000)); //Timeout to let Guardiand pick up log and have VAA ready
  vaaBytes = await (await fetch(vaaURL)).json();
}
</code></pre>
<ol start="4">
<li>Complete the transfer using the VAA.</li>
</ol>
<pre><code>// To complete transfer of normal ERC-20s
token_bridge.completeTransferWithPayload(VAA);

// To complete transfer of native currency
completeTransferAndUnwrapETHWithPayload(VAA);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nft-bridge"><a class="header" href="#nft-bridge">NFT Bridge</a></h1>
<p>This section will explain how to properly interact with the NFT Bridge Module in an EVM ecosystem.</p>
<h2 id="configuring-the-interface-2"><a class="header" href="#configuring-the-interface-2">Configuring the interface</a></h2>
<p><a href="https://github.com/wormhole-foundation/wormhole/tree/wonge97/evm-interface/ethereum/contracts/nft/interfaces">Here</a> is the interface for applications to interact with Wormhole's NFT Bridge.</p>
<!---
TODO
merge down the interface PR and link to actual file
-->
<p>Instantiating the interface will depend on the contract address of your development ecosystem and blockchain.</p>
<p>Below is an example line of code to instantiate the interface for mainnet Ethereum:</p>
<pre><code>address private wormhole_NFT_bridge_address = address(0x6FFd7EdE62328b3Af38FCD61461Bbfc52F5651fE);
INFTBridge NFT_bridge = INFTBridge(wormhole_nft_bridge_address);
</code></pre>
<h2 id="transferring-a-nft"><a class="header" href="#transferring-a-nft">Transferring a NFT</a></h2>
<p>The Wormhole NFT Bridge only supports tokens compliant with the ERC-721 interface, and functions by creating a 'wrapped NFT' with identical metadata. How this is implemented varies by ecosystem.</p>
<p><strong>Note</strong>: Unlike tokens, there is no attestation required for bridging NFTs.</p>
<p>To transfer a NFT, there are three steps:</p>
<ol>
<li>Initiate the NFT transfer
<ul>
<li>This function call will return a <code>sequence</code> (uint64) that is used in the VAA retrieval step</li>
</ul>
</li>
</ol>
<pre><code>transferNFT(tokenAddress, tokenID, recipientChain, recipient, nonce);
</code></pre>
<ol start="2">
<li>Retrieve the emitted VAA from the Guardian Network. (Usually done by a relayer)
<ul>
<li>NFT Transfer VAAs are retrieved from the Guardian Network by the <code>emitterChainID</code>, <code>emitterAddress</code>, and <code>sequence</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-js">const emitterAddr = getEmitterAddressEth(network.NFTBridgeAddress);
const seq = parseSequenceFromLogEth(tx, network.bridgeAddress);
const vaaURL = `${config.wormhole.restAddress}/v1/signed_vaa/${network.wormholeChainId}/${emitterAddr}/${seq}`;
let vaaBytes = await (await fetch(vaaURL)).json();
while (!vaaBytes.vaaBytes) {
  console.log(&quot;VAA not found, retrying in 5s!&quot;);
  await new Promise((r) =&gt; setTimeout(r, 5000)); //Timeout to let Guardiand pick up log and have VAA ready
  vaaBytes = await (await fetch(vaaURL)).json();
}
</code></pre>
<ol start="3">
<li>Complete the NFT transfer by submitting the resultant VAA to the target chain.</li>
</ol>
<pre><code>completeTransfer(VAA);
</code></pre>
<!---
TODO

additional usecases, most specifically how to grab the origin address of the wrapped NFT
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayer-module"><a class="header" href="#relayer-module">Relayer Module</a></h1>
<p><strong><em>Disclaimer: This module is only available in devnet, and is subject to change while still in development.</em></strong></p>
<p>In order to integrate with the relayer module (which enables generic relaying), there are two requirements placed on the integrator.</p>
<ol>
<li>
<p>To receive messages, the integrator must implement the <code>wormholeReceiver</code> interface, which will be called by the relayer to deliver the requested messages. If the recipient contract does not implement this function on their contract, the delivery will automatically fail.</p>
</li>
<li>
<p>To request message delivery, the integrator must call the <code>requestDelivery(DeliveryInstructions instructions)</code> function on the relayer module.</p>
</li>
</ol>
<h2 id="receiving-messages"><a class="header" href="#receiving-messages">Receiving Messages</a></h2>
<p>Receiving messages through the relayer module is almost trivial. Simply implement the public function <code>wormholeReciever</code> in your contract that the relayer module will invoke.</p>
<pre><code>function wormholeReceiver(
    bytes[] memory vaas,
    uint16 sourceChain,
    bytes32 sourceAddress,
    bytes memory payload
)
</code></pre>
<p>This is the function takes the following four inputs:</p>
<ul>
<li><code>vaas</code>: VAAs which were requested for delivery</li>
<li><code>sourceChain</code>: Wormhole chain ID of the chain the messages were sent from</li>
<li><code>sourceAddress</code>: address which requested delivery (<em>In Wormhole format!</em>)</li>
<li><code>payload</code>: additional payload which is at the top level</li>
</ul>
<p>There are a few noteworthy items here:</p>
<ul>
<li><code>wormholeReceiver</code> function should never throw an exception. Throwing an exception here will just cause a delivery failure and <em>will not revert the transaction(!!!)</em>.</li>
<li><code>wormholeReceiver</code> will only be called with as much gas as was specified by the compute budget specified when the message delivery was requested.</li>
<li>Batch VAAs are always used by the relayer module. <code>vaas</code> is an array of all the headless VAAs for which delivery was requested. These VAAs are not verified until you have VM objects which is obtained by calling <code>core_bridge.parseAndVerifyVM</code>! (More on this in <a href="technical/evm/./bestPractices.html">Best Practices</a>)</li>
<li>The generic relay VAA will be included in the <code>vaas</code> array you receive. This VAA can be ignored, but you can use it if it's useful to you.</li>
</ul>
<h2 id="sending-messages"><a class="header" href="#sending-messages">Sending Messages</a></h2>
<p>In order to send a message to another contract, you must call <code>requestDelivery(DeliveryInstructions instructions)</code>. There are a few different things you can accomplish with this call.</p>
<p>First let's lay out the DeliveryInstructions object, which is part of the relayer module structs.</p>
<pre><code>struct DeliveryParameters {
    uint16 targetChain;
    bytes32 targetAddress;
    bytes payload;
    VAAId[] deliveryList;
    bytes relayParameters;
    bytes chainPayload;
    uint32 nonce;
    uint8 consistencyLevel;
}
</code></pre>
<ul>
<li><code>targetChain</code>: chain ID of the chain this should be delivered to</li>
<li><code>targetAddress</code>: contract address to deliver to (<em>in Wormhole format</em>)</li>
<li><code>payload</code>: additional payload which will be included in the delivery</li>
<li><code>deliveryList</code> (<em>optional</em>): mechanism for re-delivery of already existing VAAs</li>
<li><code>relayParameters</code>: information required to relay to the target env. Contains compute budget</li>
<li><code>chainPayload</code>: information used for computation efficiency when relaying to other ecosystems</li>
<li><code>nonce</code> (<em>optional</em>): If included, only messages with this nonce will be relayed</li>
<li><code>consistencyLevel</code>: how long to wait before emitting the relay request</li>
<li><code>msg.value</code>: payment in native currency to relayer that must cover the compute budget specified in the relayer parameters</li>
</ul>
<h2 id="compute-budget"><a class="header" href="#compute-budget">Compute Budget</a></h2>
<p>Part of the relay parameters is a 'computeBudget' which specifies the maximum amount of computation that can be spent executing delivery on the destination contract. This is effectively a 'gasLimit' in the EVM ecosystem, but due to the relayer network supporting blockchains that don't utilize the concept of gas, we use a more generalizable concept of 'computation budget'.</p>
<p>When requesting delivery, the caller must specify and pay for the compute budget upfront. Compute budget which is not utilized will be refunded on the target chain. If the compute budget is exhausted during the execution of the delivery, a delivery failure occurs. When a delivery failure occurs, the computation budget from the source chain is not refunded, as the relayer used it to process the failed transaction.</p>
<p>The computation 'rate' is specified by the relayer module and is different for each blockchain. The quote provided by the relayer module contains the fee for the requested compute budget AND the fixed overheads of the computation which is done by the relayer contract.</p>
<h2 id="delivery-failures"><a class="header" href="#delivery-failures">Delivery Failures</a></h2>
<p>'Delivery Failure' is a technical term in the case of the relayer module. It does not mean 'something went wrong', but rather that the relayer attempted to deliver the VAA, and was unsuccessful. There are only 3 causes of a delivery failure.</p>
<ul>
<li>The <code>wormholeReceiver</code> function is either missing or otherwise uncallable on the recipient contract.</li>
<li>The <code>wormholeReceiver</code> function encountered an exception while processing.</li>
<li>The <code>wormholeReceiver</code> function exhausted the computeBudget that was specified by the delivery requester.</li>
</ul>
<p>All three of these scenarios are controllable by the integrator. In order to avoid delivery failures, the integrators should have a top-level try-catch such that the wormholeReceiver never reverts, and should always request a worst-case compute budget since excess budget will be refunded.</p>
<h2 id="delivery-retries"><a class="header" href="#delivery-retries">Delivery Retries</a></h2>
<p>In the unfortunate scenario of a delivery failure, the VAAs can be re-delivered by requesting their delivery a second time. To accomplish this, simply list their VAA IDs in the <code>deliveryList</code> in the call.</p>
<p><strong>More info and features to come. This module is still in development.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>The Wormhole contracts were designed in a manner such that composability is the default, but maximizing composability requires that xDapp developers follow certain conventions around the sending and receiving of messages.</p>
<h1 id="sending-messages-1"><a class="header" href="#sending-messages-1">Sending Messages</a></h1>
<p>When sending messages, you should follow the same paradigm as is used by the Wormhole modules, namely</p>
<ul>
<li>Don't couple the message emission to the message delivery</li>
<li>Pass through all the optional arguments (like nonce)</li>
<li>Always return the sequence</li>
</ul>
<h3 id="good-example"><a class="header" href="#good-example">Good Example</a></h3>
<pre><code class="language-solidity">// This function defines a super simple Wormhole 'module'.
// A module is just a piece of code which knows how to emit a composable message
// which can be utilized by other contracts.
function emitMyMessage(address intendedRecipient, uint32 nonce)
        public returns (uint64 sequence) {

    // Nonce is passed though to the core bridge.
    // This allows other contracts to utilize it for batching or processing.

    // intendedRecipient is key for composability!
    // This field will allow the destination contract to enforce
    // that the correct contract is submitting this VAA.

    // 1 is the consistency level,
    // this message will be emitted after only 1 block
    sequence = core_bridge.publishMessage(nonce, &quot;My Message to &quot; + intendedRecipient, 1);

    // The sequence is passed back to the caller, which can be useful relay information.
    // Relaying is not done here, because it would 'lock' others into the same relay mechanism.
}

// This portion of the code which deals with composition and delivery.
// Its job is to string together multiple modules, and ensure they get relayed
// This code can be private or public, because it's tightly coupled to application.
// Do whatever you need to here.
function sendMyMessage() private {

    // First, emit a message intended for MY_OTHER_CONTRACT with nonce zero.
    // Because processMyMessage enforces that msg.sender must equal the intendedRecipient,
    // no one but MY_OTHER_CONTRACT will be able to call processMyMessage
    // with the message emitted from this transaction.

    // However, another contract could call emitMyMessage in a different transaction
    // using their own address as the recipient.

    // This allows for composability of the module logic while still being secure!

    emitMyMessage(MY_OTHER_CONTRACT, 0);

    // Suppose I also want to send tokens to my contract on the OTHER_CHAIN
    // Because transferTokensWithPayload is a composable message, I can include it.
    // Because the nonce of both these messages is 0, they will be combined into a batch VAA.
    // NOTE: transferTokens (the basic transfer) is NOT considered a composable message

    token_bridge.transferTokensWithPayload(SOME_TOKEN, SOME_AMOUNT, OTHER_CHAIN, MY_OTHER_CONTRACT,
    0, null);

    // Lastly, I request that the batch for nonce 0 be delivered to MY_OTHER_CONTRACT
    relayer_contract.requestDelivery(OTHER_CHAIN, MY_OTHER_CONTRACT, 0, getRelayerFeeAmount());
}
</code></pre>
<h1 id="receiving-messages-1"><a class="header" href="#receiving-messages-1">Receiving Messages</a></h1>
<p>The best practices for receiving messages employ similar concepts. You should keep in mind that other contracts might want to integrate with your specific logic. As such, you shouldn't tie your verification logic to the delivery mechanism of your VAAs, and you should also give external integrators a safe way to compose with your module.</p>
<h3 id="critical"><a class="header" href="#critical"><strong><em>Critical!</em></strong></a></h3>
<ul>
<li>
<p>Always verify that the emitterAddress of the VAA comes from a contract you trust.</p>
</li>
<li>
<p>If the message should not be allowed to be 'replayed', immediately mark its hash as processed.</p>
</li>
<li>
<p>If your VAAs aren't replayable, you almost always want to include and enforce an intended recipient. Otherwise anyone can call your verify function directly with the single VAA, which will make life much harder for you and your integrators who want to process multiple VAAs at once. This is referred to as a 'scoop' exploit.</p>
</li>
</ul>
<h3 id="composability"><a class="header" href="#composability">Composability</a></h3>
<ul>
<li>When processing a VAA, always treat the messages as single VAAs. Destructuring batch VAAs is the responsibility of the integrator.</li>
<li>Once you have the function written to verify your message, pretend you are an external integrator.</li>
</ul>
<h3 id="good-example-1"><a class="header" href="#good-example-1">Good Example</a></h3>
<pre><code>// Verification accepts a single VAA, and is publicly callable.
function processMyMessage(bytes32 memory VAA) public {
    // This call accepts single VAAs and headless VAAs
    (IWormhole.VM memory vm, bool valid, string memory reason) =
        core_bridge.parseAndVerifyVM(VAA);

    // Ensure core contract verification succeeded.
    require(valid, reason);

    // Ensure the emitterAddress of this VAA is a trusted address
    require(myTrustedContracts[vm.emitterChainId] ==
        vm.emitterAddress, &quot;Invalid Emitter Address!&quot;);

    // Check that the VAA hasn't already been processed (replay protection)
    require(!processedMessages[vm.hash], &quot;Message already processed&quot;);

    // Check that the contract which is processing this VAA is the intendedRecipient
    // If the two aren't equal, this VAA may have bypassed its intended entrypoint.
    // This exploit is referred to as 'scooping'.
    require(parseIntendedRecipient(vm.payload) == msg.sender);

    // Add the VAA to processed messages so it can't be replayed
    processedMessages[vm.hash] = true

    // The message content can now be trusted.
    doBusinessLogic(vm.payload)
}

//This is the function which would receive the the VAA from the relayer
function receiveVAA(bytes32 memory batchVAA) public {
    // First, call the core bridge to verify the batchVAA
    // All the individual VAAs inside the batchVAA will be cached,
    // and you will receive headless VAAs inside the VM2 object.
    // Headless VAAs are verifiable by parseAndVerifyVM.

    (IWormhole.VM2 memory vm2, bool valid, string memory reason) =
        core_bridge.parseAndVerifyBatchVM(batchVAA, true);

    // I know from sendMyMessage that the first VAA is a token bridge VAA,
    // so let's hand that off to the token bridge module.
    bytes vaaData = token_bridge.completeTransferWithPayload(vm2.payloads[0]);

    // The second VAA is my message, let's hand that off to my module.
    processMyMessage(vm2.payloads[1]);

    // Lastly, uncache the headless VAAs from the core bridge.
    // This refunds a significant amount of gas.
    core_bridge.clearBatchCache(vm2.hashes);
}
</code></pre>
<!--
TODO these are not actually functioning examples and some of the interactions are incorrect. Demonstrates the concept.
>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solana-1"><a class="header" href="#solana-1">Solana</a></h1>
<p>The implementation contracts for Wormhole's official Solana integration can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/solana">here</a>.</p>
<p>The deployed contract addresses can be found on the <a href="technical/solana/../../reference/contracts.html">Contracts page</a>.</p>
<p>Solana is a rust-based programming environment. You'll likely find the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/rust">Wormhole Rust SDK</a> useful.</p>
<p>The Solana integration is also fully supported by the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/js">Wormhole Typescript SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cosmos-1"><a class="header" href="#cosmos-1">Cosmos</a></h1>
<p>The implementation contracts for Wormhole's official Cosmos integration can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/cosmwasm">here</a>.</p>
<p>The deployed contract addresses can be found on the <a href="technical/cosmos/../../reference/contracts.html">Contracts page</a>.</p>
<p>Cosmos is a rust-based programming environment. You'll likely find the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/rust">Wormhole Rust SDK</a> useful.</p>
<p>The Cosmos integration is also fully supported by the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/js">Wormhole Typescript SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorand-1"><a class="header" href="#algorand-1">Algorand</a></h1>
<p>The implementation contracts for Wormhole's official Algorand integration can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/algorand">here</a>.</p>
<p>An overview of the contracts and how they work is outlined <a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/algorand/README.md">here</a>.</p>
<p>The deployed contract addresses can be found on the <a href="technical/algorand/../../reference/contracts.html">Contracts page</a>.</p>
<p>The Algorand integration is also fully supported by the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/js">Wormhole Typescript SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="near-1"><a class="header" href="#near-1">NEAR</a></h1>
<p>The implementation contracts for Wormhole's official NEAR integration can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/near">here</a>.</p>
<p>The deployed contract addresses can be found on the <a href="technical/near/../../reference/contracts.html">Contracts page</a>.</p>
<p>NEAR is a rust-based programming environment. You'll likely find the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/rust">Wormhole Rust SDK</a> useful.</p>
<p>The NEAR integration is also fully supported by the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/js">Wormhole Typescript SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aptos-1"><a class="header" href="#aptos-1">Aptos</a></h1>
<p>Aptos is currently only supported in testnet.</p>
<p>The official Wormhole integration can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/aptos/integration">here</a>.</p>
<p>Information for how to integrate with these contracts can be found <a href="https://github.com/wormhole-foundation/wormhole/tree/aptos/integration/aptos/README.md">here</a>.</p>
<p>The deployed contract addresses can be found on the <a href="technical/aptos/../../reference/contracts.html">Contracts page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayer-development"><a class="header" href="#relayer-development">Relayer Development</a></h1>
<p>This chapter will help you with relayer development in the Wormhole ecosystem.</p>
<p>The two broad categorizations of relayers are <a href="technical/relayer/./genericRelayer.html">Generic Relayers</a> and <a href="technical/relayer/./specializedRelayers.html">Specialized Relayers</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-relayers-2"><a class="header" href="#generic-relayers-2">Generic Relayers</a></h1>
<p>The defining characteristic of generic relayers is that they do not have any off-chain components for the xDapp developer. All aspects of this integration are on chain.</p>
<p>The implementation details vary by blockchain so you should reference the <code>relayer module</code> documentation for each ecosystem. However, the general workflow is the same.</p>
<p>Developers are responsible for implementing a standardized interface which is part of the API agreement with the generic relayer network. This interface generally looks something like</p>
<pre><code>wormholeReceiver(
    bytes[] batchVAA,
    sourceChain
    sourceAddress
    payload)
</code></pre>
<p>This is the entrypoint on your contract which will be called by the relayer.</p>
<p>You are able to request delivery of a VAA via calling the <code>relayer module</code> on-chain. As part of the delivery request, you are required to specify and pre-pay a 'future compute' budget, which will designate a limit for how much budget can be spent on the target transaction.</p>
<p>This interface is generally along the lines of:</p>
<pre><code>requestDelivery(
    targetChain,
    targetAddress,
    computeBudget,
    nonce,
    consistencyLevel,
)
</code></pre>
<p>If the requested delivery either runs out of compute budget or throws an exception, the delivery will fail. In the case of a delivery failure, you're always able to request a second delivery. However, the prepaid fee is not refunded. Thus, it is recommended to always place a top-level try-catch around your entrypoint, and to specify a worst-case computation budget. <!-- TODO mention refunds --></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specialized-relayers-2"><a class="header" href="#specialized-relayers-2">Specialized Relayers</a></h1>
<p>Rather than home-rolling a relayer, it's recommended that integrators start from the existing <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/relayer/spy_relayer">Spy Relayer</a> provided in the Wormhole Core Repository.</p>
<p>Additionally there's an extensible relayer (called the <a href="https://github.com/wormhole-foundation/wormhole/tree/feat/plugin_relayer/relayer/plugin_relayer">Plugin Relayer</a>) currently in development.</p>
<!-- To aid in the development of relayers, a extensible relayer implementation (called the [plugin relayer]()) has been provided in the Wormhole Core Repository.

It's recommended that integrators create their own plugin for the plugin relayer, rather than home-roll a relayer themselves. Using the plugin relayer allows integrators to take advantage of the robust hot-wallet and scheduling built into the relayer's kernel, as well as leveraging plugins which are built by other integrators.  -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="wormhole-typescript-sdk-1"><a class="header" href="#wormhole-typescript-sdk-1">Wormhole Typescript SDK</a></h1>
<p>A Wormhole Typescript SDK provided for applications that only need to interact with the Core and Token Bridge contracts off-chain.</p>
<p>It can be installed using npm:</p>
<pre><code class="language-sh">npm i @certusone/wormhole-sdk
</code></pre>
<p>The following sections will explain and provide examples of how to perform key functions with Wormhole using the Typescript SDK.</p>
<p>For more examples with a more exhaustive coverage of all the supported blockchains in Wormhole, be sure to check the <a href="https://github.com/wormhole-foundation/wormhole/tree/dev.v2/sdk/js">official codebase</a> for the Typescript SDK.</p>
<p>Virtually all functions of the SDK are demonstrated in the <a href="https://github.com/wormhole-foundation/example-token-bridge-ui">reference bridge UI</a>, which makes it an excellent source of example code as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registering-tokens"><a class="header" href="#registering-tokens">Registering Tokens</a></h1>
<p>Registering tokens with the token bridge can be done from any supported blockchain, and only needs to be done once - globally - per token. This is is typically done via a UI (such as <a href="technical/typescript/portalbridge.com">Portal</a>) rather than done on-chain.</p>
<p>If you need to do it programmatically, you can also use the Typescript SDK to attest a token.</p>
<p>There are three steps to registerring a token:</p>
<ol>
<li>Create an AttestMeta VAA by calling <code>attest()</code> function from the SDK and passing in the Token Bridge address, and the address of the Token we want to attest.</li>
</ol>
<p>For example, here is the code to produce an attestation VAA using ethers:</p>
<pre><code class="language-js">const networkTokenAttestation = await attestFromEth(
  network.tokenBridgeAddress, // Token Bridge Address
  signer, //Private Key to sign and pay for TX + RPC Endpoint
  network.testToken //Token Address
);
</code></pre>
<p>The attestation transaction will produce a signed VAA. This signed VAA is necessary in order to register the tokens on other chains.</p>
<ol start="2">
<li>Retrieve the VAA with the <code>emitterAddress</code> of the Token Bridge and the <code>sequence</code> from the logs of the transaction receipt.</li>
</ol>
<p>With those, you can fetch the VAA from any Guardian REST endpoint. It could take a moment (up to 30 seconds) for the Guardian to see and sign the VAA, so it's a good idea to poll the Guardian every few seconds until the VAA is found.</p>
<p>Here is a relatively compact piece of code which is able to fetch <strong>any</strong> VAA, given an emitter address and sequence number.</p>
<pre><code class="language-js">const emitterAddr = getEmitterAddressEth(network.tokenBridgeAddress);
const seq = parseSequenceFromLogEth(
  networkTokenAttestation,
  network.bridgeAddress
);
const vaaURL = `${config.wormhole.restAddress}/v1/signed_vaa/${network.wormholeChainId}/${emitterAddr}/${seq}`;
console.log(&quot;Searching for: &quot;, vaaURL);
let vaaBytes = await (await fetch(vaaURL)).json();
while (!vaaBytes.vaaBytes) {
  console.log(&quot;VAA not found, retrying in 5s!&quot;);
  await new Promise((r) =&gt; setTimeout(r, 5000)); //Timeout to let Guardiand pick up log and have VAA ready
  vaaBytes = await (await fetch(vaaURL)).json();
}
</code></pre>
<ol start="3">
<li>Submit the VAA onto the target chain to create a wrapped version of the token by calling <code>createWrapped()</code>.</li>
</ol>
<p>You can get the new wrapped token address by calling the <code>wrappedAsset()</code> function of the TokenBridge.</p>
<p>Here is how this can be accomplished using Ethers:</p>
<pre><code class="language-js">await targetTokenBridge.createWrapped(
  Buffer.from(vaaBytes.vaaBytes, &quot;base64&quot;),
  {
    gasLimit: 2000000,
  }
);
await new Promise((r) =&gt; setTimeout(r, 5000)); //Time out to let block propogate
const wrappedTokenAddress = await targetTokenBridge.wrappedAsset(
  network.wormholeChainId,
  Buffer.from(tryNativeToHexString(network.testToken, &quot;ethereum&quot;), &quot;hex&quot;)
);
console.log(&quot;Wrapped token created at: &quot;, wrappedTokenAddress);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-transfers"><a class="header" href="#token-transfers">Token Transfers</a></h1>
<!-- //TODO this information should be captured elsewhere One challenge that arises for new EVM developers is that, because EVM uses unsigned integers, there's no concept of decimals. Therefore, tokens usually have up to 18 zeros behind them to denote up to 18 decimal places. Wormhole normalizes this to *eight* zeros, with transfer amounts rounded down to the nearest 8th decimal.  -->
<p>Before transferring tokens, you should ensure that the token is <a href="technical/typescript/./attestingToken.html">registered</a> on the chain you are transferring to, and that any necessary prerequisite steps (such as sending token approvals or creating associated token accounts) have already been done.</p>
<p>There are four steps to transferring a token:</p>
<ol>
<li>If not already done, complete a standard ERC-20 token approval prior to performing a bridge action if you're in the EVM ecosystem.</li>
</ol>
<pre><code class="language-js">// Here we are approving and transfering 50 tokens. The ERC20 token we are transfering has 18 decimal places.
const bridgeAmt = ethers.utils.parseUnits(&quot;50&quot;, &quot;18&quot;);

await treasury.approveTokenBridge(bridgeAmt, {
  gasLimit: 2000000,
});
</code></pre>
<ol start="2">
<li>Initate a transfer by calling <code>transfer</code> on the token bridge module which will create a transfer VAA. </li>
</ol>
<p><em>Note that the target receipient is a Wormhole-format address (referred to as 'hex' format in the Typescript SDK).</em></p>
<pre><code class="language-js">const targetRecepient = Buffer.from(
  tryNativeToHexString(targetDeployment.deployedAddress, &quot;ethereum&quot;),
  &quot;hex&quot;
);

const tx = await (
  await treasury.bridgeToken(
    bridgeAmt,
    targetNetwork.wormholeChainId,
    targetRecepient
  )
).wait();
</code></pre>
<ol start="3">
<li>Retrieve the VAA with the <code>emitterAddress</code> of the Token Bridge and the <code>sequence</code> from the logs of the transaction receipt. (This is the same code as shown in the previous section.)</li>
</ol>
<pre><code class="language-js">const emitterAddr = getEmitterAddressEth(network.tokenBridgeAddress);
const seq = parseSequenceFromLogEth(tx, network.bridgeAddress);
const vaaURL = `${config.wormhole.restAddress}/v1/signed_vaa/${network.wormholeChainId}/${emitterAddr}/${seq}`;
let vaaBytes = await (await fetch(vaaURL)).json();
while (!vaaBytes.vaaBytes) {
  console.log(&quot;VAA not found, retrying in 5s!&quot;);
  await new Promise((r) =&gt; setTimeout(r, 5000)); //Timeout to let Guardiand pick up log and have VAA ready
  vaaBytes = await (await fetch(vaaURL)).json();
}
</code></pre>
<ol start="4">
<li>Submit the VAA to the target chain by calling <code>completeTransfer()</code>.</li>
</ol>
<p>If you're not using a relayer, you'll have to submit the target chain transaction yourself. <a href="technical/typescript/./polygon-oasis-relayer.html">This section</a> outlines how to use relayers.</p>
<pre><code class="language-js">const completeTransferTx = await targetTokenBridge.completeTransfer(
  Buffer.from(vaaBytes.vaaBytes, &quot;base64&quot;)
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-ecosystem-token-transfer"><a class="header" href="#cross-ecosystem-token-transfer">Cross-Ecosystem Token Transfer</a></h1>
<p>A defining feature of cross chain apps (xDapps) is the ability to move tokens from one chain to another, even if those blockchains have radically different virtual machine models.</p>
<p>To demonstrate, let’s do a simple programmatic transfer from Ethereum to Solana.</p>
<p>First, determine the address on Solana where we're sending the tokens. Unlike EVM chains where the wallet address is used, we need to send the tokens to the recipient's associated token account for that token. We'll use a couple helper functions from the Wormhole Typescript SDK to make this easier.</p>
<pre><code class="language-ts">import {
  Token,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} from &quot;@solana/spl-token&quot;;
import {
  getForeignAssetSolana,
  hexToUint8Array,
  nativeToHexString,
  CHAIN_ID_ETH,
} from &quot;@certusone/wormhole-sdk&quot;;

const SOLANA_TOKEN_BRIDGE_ADDRESS =
  &quot;wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb&quot;;
// determine destination address - an associated token account
const solanaMintKey = new PublicKey(
  (await getForeignAssetSolana(
    connection,
    SOLANA_TOKEN_BRIDGE_ADDRESS,
    CHAIN_ID_ETH,
    hexToUint8Array(nativeToHexString(tokenAddress, CHAIN_ID_ETH) || &quot;&quot;)
  )) || &quot;&quot;
);
const recipientAddress = await Token.getAssociatedTokenAddress(
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  solanaMintKey,
  recipientWalletAddress
);
</code></pre>
<p>After we have the receipt token account on Solana, it's time to submit the transfer message on Ethereum. This will output a log that contains a sequence number (a unique number for the message) and an emitter address (the ETH Token Bridge Address in Wormhole format). The sequence number and emitter address will be used to fetch the VAA after it’s been signed by Guardians.</p>
<pre><code class="language-ts">import {
  trasnferFromEth,
  parseSequenceFromLogEth,
  getEmitterAddressEth,
  CHAIN_ID_SOLANA,
} from &quot;@certusone/wormhole-sdk&quot;;

const ETH_TOKEN_BRIDGE_ADDRESS = &quot;0x3ee18B2214AFF97000D974cf647E7C347E8fa585&quot;;

// Submit transaction - results in a Wormhole message being published
const receipt = await transferFromEth(
  ETH_TOKEN_BRIDGE_ADDRESS,
  signer,
  tokenAddress,
  amount,
  CHAIN_ID_SOLANA,
  recipientAddress
);
// Get the sequence number and emitter address required to fetch the signedVAA of our message
const sequence = parseSequenceFromLogEth(receipt, ETH_BRIDGE_ADDRESS);
const emitterAddress = getEmitterAddressEth(ETH_TOKEN_BRIDGE_ADDRESS);
</code></pre>
<p>Once the Guardians have signed the token bridge VAA, it needs to be retrieved from the Guardian Network. This time we'll use the Guardian GRPC endpoint, though the REST endpoint used in previous sections works as well.</p>
<pre><code class="language-ts">import { getSignedVAA } from &quot;@certusone/wormhole-sdk&quot;;

// Fetch the signedVAA from the Wormhole Network (this may require retries while you wait for confirmation)
const { signedVAA } = await getSignedVAA(
  WORMHOLE_RPC_HOST,
  CHAIN_ID_ETH,
  emitterAddress,
  sequence
);
</code></pre>
<p>Now, we post the VAA to Solana in order to mint the wrapped tokens. Because of the compute limit on Solana, we split the signature verification and token claim into steps. To do that, verify all the signatures and create a claim account for the token.</p>
<pre><code class="language-ts">const SOL_BRIDGE_ADDRESS = &quot;worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth&quot;;
await postVaaSolana(
  connection, // Solana Mainnet Connection
  wallet, //Solana Wallet Signer
  SOL_BRIDGE_ADDRESS,
  payerAddress,
  signedVAA
);
</code></pre>
<p>Finally, claim the tokens:</p>
<pre><code class="language-ts">const transaction = await redeemOnSolana(
  connection,
  SOL_BRIDGE_ADDRESS,
  SOL_TOKEN_BRIDGE_ADDRESS,
  payerAddress,
  signedVAA,
  isSolanaNative,
  mintAddress
);
const signed = await wallet.signTransaction(transaction);
const txid = await connection.sendRawTransaction(signed.serialize());
await connection.confirmTransaction(txid);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-relayers"><a class="header" href="#using-relayers">Using Relayers</a></h1>
<p>In this example, we’ll utilize the token bridge relayer network to complete a token transfer from Polygon and to Oasis.</p>
<p>This code is written for a browser environment. If you're working in node, consider using node-fetch:</p>
<pre><code class="language-bash">npm i --save @certusone/wormhole-sdk ethers node-fetch
</code></pre>
<pre><code class="language-ts">import { BigNumber, ethers } from &quot;ethers&quot;;
import fetch from &quot;node-fetch&quot;;
import {
  getEmitterAddressEth,
  hexToUint8Array,
  nativeToHexString,
  parseSequenceFromLogEth,
  CHAIN_ID_POLYGON,
  CHAIN_ID_OASIS,
  transferFromEthNative,
  getIsTransferCompletedEth,
  setDefaultWasm,
} from &quot;@certusone/wormhole-sdk&quot;;
</code></pre>
<h3 id="setup-the-polygon-and-oasis-wallets"><a class="header" href="#setup-the-polygon-and-oasis-wallets">Setup the Polygon and Oasis Wallets</a></h3>
<p>Now, set up the two wallets we’ll be sending and receiving from. While we are instantiating both wallets with their private keys, we only need the Public key of the receiving wallet for this example.</p>
<pre><code class="language-ts">const EmeraldWallet = new ethers.Wallet(
  privatekey_emerald,
  new ethers.providers.JsonRpcProvider(&quot;https://emerald.oasis.dev&quot;)
);
const PolygonWallet = new ethers.Wallet(
  privatekey_polygon,
  new ethers.providers.JsonRpcProvider(&quot;https://polygon-rpc.com/&quot;)
);
</code></pre>
<h3 id="fetch-the-fee-schedule"><a class="header" href="#fetch-the-fee-schedule">Fetch the fee schedule</a></h3>
<p>Fetch the fee schedule for the token bridge relayers. This fee schedule outlines the minimum fee for each recipient chain that relayers will accept. As long as we attach at least that fee in the relayer fee, we can expect a relayer pick up the transaction and relay it to the recipient chain. The fee will cover the gas cost for the relayer along with a little extra to make it worth their time to run the relayer service.</p>
<p>We will also define the transfer amount in this step. The fee schedule will either return a flat fee in USD for the recipient chain, or a percentage fee (usually only for Ethereum). Either way, we’ll need to calculate the fee in BigNumber format (no decimals).</p>
<pre><code class="language-ts">const transferAmount = BigNumber.from(&quot;1000000000000000000&quot;); // We are sending 1 MATIC over the wall to Oasis
const relayerFeeSchedule = await(
  await fetch(
    &quot;https://raw.githubusercontent.com/certusone/wormhole-relayer-list/main/relayer.json&quot;
  )
).json();
</code></pre>
<p>The fee schedule has the following interface:</p>
<pre><code class="language-ts">export interface RelayerFeeSchedule {
  supportedTokens: ChainAddress[];
  relayers: Relayer[];
  feeSchedule: FeeSchedule;
}

interface ChainAddress {
  chainId: number;
  address: string;
  coingeckoId: string;
}

interface Relayer {
  name: string;
  url: string;
}

interface FeeSchedule {
  [chainId: string]: {
    type: &quot;flat&quot; | &quot;percent&quot;;
    feeUsd?: number;
    feePercent?: number;
    gasEstimate?: number;
  };
}
</code></pre>
<p>After fetching the fee schedule, find the fee in wei that needs to be paid to the Relayer. At the time of writing, Oasis has a flat fee of $0.50, so to calculate how much MATIC we need to pay for the $0.50 fee, we need to fetch the MATIC price. To do that, use the free CoinGecko api:</p>
<pre><code class="language-ts">let feeWei: number;
if (relayerFeeSchedule.feeSchedule[CHAIN_ID_OASIS].type == &quot;flat&quot;) {
  const feeUsd = relayerFeeSchedule.feeSchedule[CHAIN_ID_OASIS].feeUsd;
  const MATIC_PRICE = await(
    await fetch(
      &quot;https://api.coingecko.com/api/v3/simple/token_price/polygon-pos?contract_addresses=0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270&amp;vs_currencies=usd&quot;
    )
  ).json()[&quot;0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270&quot;][&quot;usd&quot;];

  feeWei = (feeUsd / MATIC_PRICE) * 1e18;
} else if (relayerFeeSchedule.feeSchedule[CHAIN_ID_OASIS].type == &quot;percent&quot;) {
  let feeWei =
    (relayerFeeSchedule.feeSchedule[CHAIN_ID_OASIS].feePercent / 100) *
    transferAmount.toNumber();
}
</code></pre>
<h3 id="overrides--quirks"><a class="header" href="#overrides--quirks">Overrides &amp; Quirks</a></h3>
<p>Dependent on the specific blockchains you are working with, you may need to perform special actions when submitting this transaction. Because we're dealing with Polygon in this example, there's an additional step to overestimate the gas. This is because Ethers library has some problems with fee estimation after EIP-1559.</p>
<pre><code class="language-ts">let overrides;
let feeData = await PolygonWallet.provider.getFeeData();
overrides = {
  maxFeePerGas: feeData.maxFeePerGas?.mul(50) || undefined,
  maxPriorityFeePerGas: feeData.maxPriorityFeePerGas?.mul(50) || undefined,
};
</code></pre>
<h3 id="emit-token-bridge-message"><a class="header" href="#emit-token-bridge-message">Emit Token Bridge Message</a></h3>
<p>Now we have all the pieces we need to emit a token bridge message with a relay fee attached. We do this using the transferFromEthNative() method. EthNative is used because we’re transferring the native token of the Polygon network rather than an ERC20 token.</p>
<pre><code class="language-ts">const POLYGON_TOKEN_BRIDGE = &quot;0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE&quot;;

const receipt = await transferFromEthNative(
  POLYGON_TOKEN_BRIDGE,
  PolygonWallet,
  transferAmount,
  CHAIN_ID_OASIS,
  hexToUint8Array(
    nativeToHexString(await EmeraldWallet.getAddress(), CHAIN_ID_OASIS) || &quot;&quot;
  ),
  BigNumber.from(feeWei.toString()),
  overrides
);
console.log(&quot;Receipt: &quot;, receipt);

const POLYGON_CORE_BRIDGE_ADDRESS =
  &quot;0x7A4B5a56256163F07b2C80A7cA55aBE66c4ec4d7&quot;;
const sequence = parseSequenceFromLogEth(receipt, POLYGON_CORE_BRIDGE_ADDRESS);
const emitterAddress = getEmitterAddressEth(POLYGON_TOKEN_BRIDGE);
console.log(&quot;Sequence: &quot;, sequence);
console.log(&quot;EmitterAddress: &quot;, emitterAddress);
</code></pre>
<p>Let’s walk through each of the arguments of this function and what they mean.</p>
<p><code>POLYGON_TOKEN_BRIDGE</code> is the address of the token bridge module on the Polygon network. You can find it and other addresses on the <a href="technical/typescript/../../reference/contracts.html">contracts</a> page.</p>
<p><code>PolygonWallet</code> is a signer you get from the Ethers library that holds a private key that can sign transactions.</p>
<p><code>transferAmount</code> is a BigNumber that contains the amount to transfer in the smallest unit of the network.</p>
<p><code>CHAIN_ID_OASIS</code> is a constant that identifies the target chain.</p>
<p><code>hexToUint8Array()</code> translates the target publickey into a wormhole public key.</p>
<p><code>BigNumber.from(feeWei.toString())</code> identifies the fee in smallest unit of the network for the relayer.</p>
<p><code>overrides</code> are used if we need to override the gas cost, which we need to do for Polygon.</p>
<h3 id="check-vaa-was-signed"><a class="header" href="#check-vaa-was-signed">Check VAA was signed</a></h3>
<p>Wait 15 min for finality on Polygon and then check to see if it was submitted. If successful, you’ll be able to fetch a base64 encoded vaaBytes. We need this in the next step where we check if the transaction was successfully relayed.</p>
<pre><code class="language-ts">await new Promise((r) =&gt; setTimeout(r, 900000)); //15m in seconds
const WORMHOLE_RPC = &quot;https://wormhole-v2-mainnet-api.certus.one&quot;;
let vaaBytes = undefined;
while (!vaaBytes) {
  try {
    vaaBytes = await(
      await fetch(
        `${WORMHOLE_RPC}/v1/signed_vaa/${CHAIN_ID_POLYGON}/${emitterAddress}/${sequence}`
      )
    ).json().vaaBytes;
  } catch (e) {
    await new Promise((r) =&gt; setTimeout(r, 5000));
  }
}
console.log(&quot;VAA Bytes: &quot;, vaaBytes);
</code></pre>
<h3 id="check-if-the-transfer-was-completed"><a class="header" href="#check-if-the-transfer-was-completed">Check if the transfer was completed</a></h3>
<p>In the final step, use the getIsTransferCompletedEth() method to check if the transfer was completed on the Oasis Emerald chain. If it’s not, wait 5 seconds and check again.</p>
<pre><code class="language-ts">setDefaultWasm(&quot;node&quot;); //only needed if running in node.js
const EMERALD_TOKEN_BRIDGE = &quot;0x5848C791e09901b40A9Ef749f2a6735b418d7564&quot;;
let transferCompleted = await getIsTransferCompletedEth(
  EMERALD_TOKEN_BRIDGE,
  EmeraldWallet.provider,
  vaaBytes
);
while (!transferCompleted) {
  await new Promise((r) =&gt; setTimeout(r, 5000));
  transferCompleted = await getIsTransferCompletedEth(
    EMERALD_TOKEN_BRIDGE,
    EmeraldWallet.provider,
    vaaBytes
  );
}

console.log(&quot;VAA Relayed!&quot;);
</code></pre>
<p>Success! You've programmatically relayed a transaction!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h1>
<p>Here is a collection of other resources and reference sources which you're likely to find helpful.</p>
<ul>
<li><a href="reference/./glossary.html">Glossary &amp; Terms</a></li>
<li><a href="reference/./usefulLinks.html">Tools &amp; Helpful Links</a></li>
<li><a href="reference/./contracts.html">Contract Addresses &amp; Environment Information</a></li>
<li><a href="reference/./rpcnodes.html">RPC Info</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><em>Disclaimer: In some instances, Wormhole uses general terms for decentralized, cross-chain elements as branded verbiage. In most casese, the definition of the general term does not differ from Wormhole's definition though Wormhole's definitions may be more narrow than general interpretations.</em></p>
<p><strong>Guardian</strong> - One of the 19 validators in the Guardian Network that contributes to the VAA multisig.</p>
<p><a href="reference/../wormhole/5_guardianNetwork.html"><strong>Guardian Network</strong></a> - Validators that exist in their own p2p network that serve as Wormhole's oracle by observing activity on-chain and generating signed messages attesting to that activity.</p>
<p><a href="reference/../wormhole/6_relayers.html"><strong>Relayer</strong></a> - Any process which delivers VAAs to a destination.</p>
<p><a href="reference/../wormhole/4_vaa.html"><strong>VAA</strong></a> - Verifiable Action Approvals (VAAs) are the key piece of data in the Wormhole ecosystem, containing the messages emitted by xDapps along with information such as what contract emitted the message. The VAAs are signed by the Guardians and need 13/19 signatures to be considered authentic.</p>
<p><a href="reference/../wormhole/8_wormchain.html"><strong>Wormchain</strong></a> - A purpose-built cosmos blockchain which aids the Guardian Network and allows for formal interaction with the Guardians.</p>
<p><a href="reference/../dapps/3_xdataxassets.html"><strong>xAssets</strong></a> - Chain-and-path agnostic token that exists on a layer outside the blockchain ecosystem, which can be used to conduct transactions on any blockchain. There are currently two implemented modules: (1) <a href="reference/../technical/evm/tokenLayer.html">Token Bridge Module</a> and (2) <a href="reference/../technical/evm/nftLayer.html">NFT Bridge Module</a></p>
<p><strong>xChain</strong> - Term that refers to the full range of cross-blockchain interoperability.</p>
<p><a href="reference/../dapps/4_whatIsanXdapp.html"><strong>xDapp</strong></a> - Decentralized application that enables users to create and/or use xData.</p>
<p><a href="reference/../dapps/3_xdataxassets.html"><strong>xData</strong></a> - Data that exists in a layer outside of Layer 1 blockchains, which is accessible by all chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-and-useful-links"><a class="header" href="#tools-and-useful-links">Tools and Useful Links</a></h1>
<p>Below are a variety of tools and information in the Wormhole ecosystem that can help you develop xDapps.</p>
<h3 id="design-documents"><a class="header" href="#design-documents"><a href="https://github.com/certusone/wormhole/tree/dev.v2/whitepapers">Design Documents</a></a></h3>
<p>Wormhole's component design specifications outline the reasoning behind design decisions with added technical depth.</p>
<h3 id="testnet-1"><a class="header" href="#testnet-1">Testnet</a></h3>
<p>Wormhole has deployed Core Bridge, Token Bridge and NFT Bridge contracts on various testnets of the chains connected by Wormhole. You can see the deployed addresses <a href="reference/./contracts.html">here</a>. </p>
<p><em>Note: There's only a single Guardian that oversees the testnets, so you might experience a higher rate of missed VAAs than you would on mainnet.</em></p>
<h3 id="testnet-bridge-ui"><a class="header" href="#testnet-bridge-ui"><a href="https://wormhole-foundation.github.io/example-token-bridge-ui/#/transfer">Testnet Bridge UI</a></a></h3>
<p>An example UI provided to test out attesting and bridging tokens on testnet.</p>
<h3 id="tilt"><a class="header" href="#tilt">Tilt</a></h3>
<p>Tilt is a Kubernetes-based tool that runs a copy of every chain along side a Guardian node to create a simulated testing environment. Details on how to set it up and test against it is <a href="reference/../development/tilt/overview.html">here</a>.</p>
<h3 id="wormhole-core-repository-1"><a class="header" href="#wormhole-core-repository-1">Wormhole Core Repository</a></h3>
<p>The Wormhole core repository can be found at <a href="https://github.com/wormhole-foundation/wormhole">https://github.com/wormhole-foundation/wormhole</a>.</p>
<h3 id="wormhole-explorer"><a class="header" href="#wormhole-explorer"><a href="https://wormholenetwork.com/en/explorer">Wormhole Explorer</a></a></h3>
<p>Tool to observe all Wormhole activity and can help you parse VAAs after they've been picked up the Guardian network.</p>
<h3 id="wormhole-sdk"><a class="header" href="#wormhole-sdk">Wormhole SDK</a></h3>
<p>The SDK is a set of Javascript tools to help you do Token Bridge transfers, plus fetch and submit VAAs from one chain to another. You can install it via <a href="https://www.npmjs.com/package/@certusone/wormhole-sdk">NPM</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts"><a class="header" href="#contracts">Contracts</a></h1>
<p>Here you can find the addresses for the deployed contracts on all the chains that Wormhole supports, including testnet.</p>
<p>The <a href="https://github.com/wormhole-foundation/wormhole/blob/dev.v2/sdk/js/src/utils/consts.ts">constants</a> of the Wormhole SDK always has the most up-to-date contract addresses, along with additional useful constants. Check there if something you're looking for isn't found here.</p>
<h2 id="mainnet"><a class="header" href="#mainnet">Mainnet</a></h2>
<h3 id="core-bridge"><a class="header" href="#core-bridge">Core Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">mainnet-beta</td><td style="text-align: left">worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left">1</td><td style="text-align: left">0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</td></tr>
<tr><td style="text-align: left">Terra Classic</td><td style="text-align: left">3</td><td style="text-align: left">columbus-5</td><td style="text-align: left">terra1dq03ugtd40zu9hcgdzrsq6z2z4hwhc9tqk2uy5</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">56</td><td style="text-align: left">0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</td></tr>
<tr><td style="text-align: left">Polygon</td><td style="text-align: left">5</td><td style="text-align: left">137</td><td style="text-align: left">0x7A4B5a56256163F07b2C80A7cA55aBE66c4ec4d7</td></tr>
<tr><td style="text-align: left">Avalanche (C-Chain)</td><td style="text-align: left">6</td><td style="text-align: left">43114</td><td style="text-align: left">0x54a8e5f9c4CbA08F9943965859F6c34eAF03E26c</td></tr>
<tr><td style="text-align: left">Oasis (Emerald)</td><td style="text-align: left">7</td><td style="text-align: left">4262</td><td style="text-align: left">0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161554</td><td style="text-align: left">0xa321448d90d4e5b0A732867c18eA198e75CAC48E</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">250</td><td style="text-align: left">0x126783A6Cb203a3E35344528B26ca3a0489a1485</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0xa321448d90d4e5b0A732867c18eA198e75CAC48E</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0xa321448d90d4e5b0A732867c18eA198e75CAC48E</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">8217</td><td style="text-align: left">0x0C21603c4f3a6387e241c0091A7EA39E43E90bb7</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">42220</td><td style="text-align: left">0xa321448d90d4e5b0A732867c18eA198e75CAC48E</td></tr>
<tr><td style="text-align: left">NEAR</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">contract.wormhole_crypto.near</td></tr>
<tr><td style="text-align: left">Moonbeam</td><td style="text-align: left">16</td><td style="text-align: left">1284</td><td style="text-align: left">0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">18</td><td style="text-align: left">phoenix-1</td><td style="text-align: left">terra12mrnzvhx3rpej6843uge2yyfppfyd3u9c3uq223q8sl48huz9juqffcnh</td></tr>
</tbody></table>
<h4 id="core-bridge---read-only"><a class="header" href="#core-bridge---read-only">Core Bridge - Read Only</a></h4>
<p>These chains can <em>verify</em> Wormhole messages submitted to them, but cannot <em>emit</em> messages for other chains.</p>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Arbitrum</td><td style="text-align: left">23</td><td style="text-align: left">42161</td><td style="text-align: left">0xa5f208e072434bC67592E4C49C1B991BA79BCA46</td></tr>
<tr><td style="text-align: left">Optimism</td><td style="text-align: left">24</td><td style="text-align: left">10</td><td style="text-align: left">0xEe91C335eab126dF5fDB3797EA9d6aD93aeC9722</td></tr>
<tr><td style="text-align: left">Gnosis</td><td style="text-align: left">25</td><td style="text-align: left">100</td><td style="text-align: left">0xa321448d90d4e5b0A732867c18eA198e75CAC48E</td></tr>
</tbody></table>
<h3 id="token-bridge-1"><a class="header" href="#token-bridge-1">Token Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">mainnet-beta</td><td style="text-align: left">wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left">1</td><td style="text-align: left">0x3ee18B2214AFF97000D974cf647E7C347E8fa585</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left">columbus-5</td><td style="text-align: left">terra10nmmwe8r3g99a9newtqa7a75xfgs2e8z87r2sf</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">56</td><td style="text-align: left">0xB6F6D86a8f9879A9c87f643768d9efc38c1Da6E7</td></tr>
<tr><td style="text-align: left">Polygon</td><td style="text-align: left">5</td><td style="text-align: left">137</td><td style="text-align: left">0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</td></tr>
<tr><td style="text-align: left">Avalanche (C-Chain)</td><td style="text-align: left">6</td><td style="text-align: left">43114</td><td style="text-align: left">0x0e082F06FF657D94310cB8cE8B0D9a04541d8052</td></tr>
<tr><td style="text-align: left">Oasis (Emerald)</td><td style="text-align: left">7</td><td style="text-align: left">4262</td><td style="text-align: left">0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161554</td><td style="text-align: left">0x51b5123a7b0F9b2bA265f9c4C8de7D78D52f510F</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">250</td><td style="text-align: left">0x7C9Fc5741288cDFdD83CeB07f3ea7e22618D79D2</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">8217</td><td style="text-align: left">0x5b08ac39EAED75c0439FC750d9FE7E1F9dD0193F</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">42220</td><td style="text-align: left">0x796Dff6D74F3E27060B71255Fe517BFb23C93eed</td></tr>
<tr><td style="text-align: left">NEAR</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">contract.portalbridge.near</td></tr>
<tr><td style="text-align: left">Moonbeam</td><td style="text-align: left">16</td><td style="text-align: left">1284</td><td style="text-align: left">0xb1731c586ca89a23809861c6103f0b96b3f57d92</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">18</td><td style="text-align: left">phoenix-1</td><td style="text-align: left">terra153366q50k7t8nn7gec00hg66crnhkdggpgdtaxltaq6xrutkkz3s992fw9</td></tr>
</tbody></table>
<h3 id="nft-bridge-1"><a class="header" href="#nft-bridge-1">NFT Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">mainnet-beta</td><td style="text-align: left">WnFt12ZrnzZrFZkt2xsNsaNWoQribnuQ5B5FrDbwDhD</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left">1</td><td style="text-align: left">0x6FFd7EdE62328b3Af38FCD61461Bbfc52F5651fE</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">56</td><td style="text-align: left">0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</td></tr>
<tr><td style="text-align: left">Polygon</td><td style="text-align: left">5</td><td style="text-align: left">137</td><td style="text-align: left">0x90BBd86a6Fe93D3bc3ed6335935447E75fAb7fCf</td></tr>
<tr><td style="text-align: left">Avalanche (C-Chain)</td><td style="text-align: left">6</td><td style="text-align: left">43114</td><td style="text-align: left">0xf7B6737Ca9c4e08aE573F75A97B73D7a813f5De5</td></tr>
<tr><td style="text-align: left">Oasis (Emerald)</td><td style="text-align: left">7</td><td style="text-align: left">4262</td><td style="text-align: left">0x04952D522Ff217f40B5Ef3cbF659EcA7b952a6c1</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161554</td><td style="text-align: left">0x6dcC0484472523ed9Cdc017F711Bcbf909789284</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">250</td><td style="text-align: left">0xA9c7119aBDa80d4a4E0C06C8F4d8cF5893234535</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">8217</td><td style="text-align: left">0x3c3c561757BAa0b78c5C025CdEAa4ee24C1dFfEf</td></tr>
<tr><td style="text-align: left">Moonbeam</td><td style="text-align: left">16</td><td style="text-align: left">1284</td><td style="text-align: left">0x453cfbe096c0f8d763e8c5f24b441097d577bde2</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">42220</td><td style="text-align: left">0xA6A377d75ca5c9052c9a77ED1e865Cc25Bd97bf3</td></tr>
</tbody></table>
<h2 id="testnet-2"><a class="header" href="#testnet-2">Testnet</a></h2>
<h3 id="core-bridge-1"><a class="header" href="#core-bridge-1">Core Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">devnet</td><td style="text-align: left">3u8hJUVTA4jH1wYAyUur7FFZVQ8H635K3tSHHF4ssjQ5</td></tr>
<tr><td style="text-align: left">Ethereum (Goerli)</td><td style="text-align: left">2</td><td style="text-align: left">5</td><td style="text-align: left">0x706abc4E45D419950511e474C7B9Ed348A4a716c</td></tr>
<tr><td style="text-align: left">Ethereum (Ropsten)</td><td style="text-align: left">10001</td><td style="text-align: left">3</td><td style="text-align: left">0x210c5F5e2AF958B4defFe715Dc621b7a3BA888c5</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left">bombay-12</td><td style="text-align: left">terra1pd65m0q9tl3v8znnz5f5ltsfegyzah7g42cx5v</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">97</td><td style="text-align: left">0x68605AD7b15c732a30b1BbC62BE8F2A509D74b4D</td></tr>
<tr><td style="text-align: left">Polygon (Mumbai)</td><td style="text-align: left">5</td><td style="text-align: left">80001</td><td style="text-align: left">0x0CBE91CF822c73C2315FB05100C2F714765d5c20</td></tr>
<tr><td style="text-align: left">Avalanche (Fuji)</td><td style="text-align: left">6</td><td style="text-align: left">43113</td><td style="text-align: left">0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C</td></tr>
<tr><td style="text-align: left">Oasis (Emerald Testnet)</td><td style="text-align: left">7</td><td style="text-align: left">42261</td><td style="text-align: left">0xc1C338397ffA53a2Eb12A7038b4eeb34791F8aCb</td></tr>
<tr><td style="text-align: left">Algorand (Testnet)</td><td style="text-align: left">8</td><td style="text-align: left"></td><td style="text-align: left">86525623</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161555</td><td style="text-align: left">0xBd07292de7b505a4E803CEe286184f7Acf908F5e</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">4002</td><td style="text-align: left">0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0xE4eacc10990ba3308DdCC72d985f2a27D20c7d03</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0x4377B49d559c0a9466477195C6AdC3D433e265c0</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">1001</td><td style="text-align: left">0x1830CC6eE66c84D2F177B94D544967c774E624cA</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">44787</td><td style="text-align: left">0x88505117CA88e7dd2eC6EA1E13f0948db2D50D56</td></tr>
<tr><td style="text-align: left">NEAR</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">wormhole.wormhole.testnet</td></tr>
<tr><td style="text-align: left">Moonbase alpha</td><td style="text-align: left">16</td><td style="text-align: left">1287</td><td style="text-align: left">0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">18</td><td style="text-align: left">pisco-1</td><td style="text-align: left">terra19nv3xr5lrmmr7egvrk2kqgw4kcn43xrtd5g0mpgwwvhetusk4k7s66jyv0</td></tr>
<tr><td style="text-align: left">Injective</td><td style="text-align: left">19</td><td style="text-align: left">testnet</td><td style="text-align: left">inj1xx3aupmgv3ce537c0yce8zzd3sz567syuyedpg</td></tr>
<tr><td style="text-align: left">Aptos</td><td style="text-align: left">22</td><td style="text-align: left"></td><td style="text-align: left">0x1b1752e26b65fc24971ee5ec9718d2ccdd36bf20486a10b2973ea6dedc6cd197</td></tr>
</tbody></table>
<h3 id="token-bridge-2"><a class="header" href="#token-bridge-2">Token Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">devnet</td><td style="text-align: left">DZnkkTmCiFWfYTfT41X3Rd1kDgozqzxWaHqsw6W4x2oe</td></tr>
<tr><td style="text-align: left">Ethereum (Goerli)</td><td style="text-align: left">2</td><td style="text-align: left">5</td><td style="text-align: left">0xF890982f9310df57d00f659cf4fd87e65adEd8d7</td></tr>
<tr><td style="text-align: left">Ethereum (Ropsten)</td><td style="text-align: left">10001</td><td style="text-align: left">3</td><td style="text-align: left">0xF174F9A837536C449321df1Ca093Bb96948D5386</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left">bombay-12</td><td style="text-align: left">terra1pseddrv0yfsn76u4zxrjmtf45kdlmalswdv39a</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">97</td><td style="text-align: left">0x9dcF9D205C9De35334D646BeE44b2D2859712A09</td></tr>
<tr><td style="text-align: left">Polygon (Mumbai)</td><td style="text-align: left">5</td><td style="text-align: left">80001</td><td style="text-align: left">0x377D55a7928c046E18eEbb61977e714d2a76472a</td></tr>
<tr><td style="text-align: left">Avalanche (Fuji)</td><td style="text-align: left">6</td><td style="text-align: left">43113</td><td style="text-align: left">0x61E44E506Ca5659E6c0bba9b678586fA2d729756</td></tr>
<tr><td style="text-align: left">Oasis (Emerald Testnet)</td><td style="text-align: left">7</td><td style="text-align: left">42261</td><td style="text-align: left">0x88d8004A9BdbfD9D28090A02010C19897a29605c</td></tr>
<tr><td style="text-align: left">Algorand (Testnet)</td><td style="text-align: left">8</td><td style="text-align: left"></td><td style="text-align: left">86525641</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161555</td><td style="text-align: left">0xD05eD3ad637b890D68a854d607eEAF11aF456fba</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">4002</td><td style="text-align: left">0x599CEa2204B4FaECd584Ab1F2b6aCA137a0afbE8</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0xd11De1f930eA1F7Dd0290Fe3a2e35b9C91AEFb37</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0xebA00cbe08992EdD08ed7793E07ad6063c807004</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">1001</td><td style="text-align: left">0xC7A13BE098720840dEa132D860fDfa030884b09A</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">44787</td><td style="text-align: left">0x05ca6037eC51F8b712eD2E6Fa72219FEaE74E153</td></tr>
<tr><td style="text-align: left">Near</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">token.wormhole.testnet</td></tr>
<tr><td style="text-align: left">Moonbase alpha</td><td style="text-align: left">16</td><td style="text-align: left">1287</td><td style="text-align: left">0xbc976D4b9D57E57c3cA52e1Fd136C45FF7955A96</td></tr>
<tr><td style="text-align: left">Injective</td><td style="text-align: left">19</td><td style="text-align: left">testnet</td><td style="text-align: left">inj1q0e70vhrv063eah90mu97sazhywmeegp7myvnh</td></tr>
<tr><td style="text-align: left">Aptos</td><td style="text-align: left">22</td><td style="text-align: left"></td><td style="text-align: left">0xdd0a2618dc5564ccf38d0eca7877198fef51157fea74a6bc2e5e40b52c2a0a08</td></tr>
</tbody></table>
<h3 id="nft-bridge-2"><a class="header" href="#nft-bridge-2">NFT Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">devnet</td><td style="text-align: left">2rHhojZ7hpu1zA91nvZmT8TqWWvMcKmmNBCr2mKTtMq4</td></tr>
<tr><td style="text-align: left">Ethereum (Goerli)</td><td style="text-align: left">2</td><td style="text-align: left">5</td><td style="text-align: left">0xD8E4C2DbDd2e2bd8F1336EA691dBFF6952B1a6eB</td></tr>
<tr><td style="text-align: left">Ethereum (Ropsten)</td><td style="text-align: left">10001</td><td style="text-align: left">3</td><td style="text-align: left">0x2b048Da40f69c8dc386a56705915f8E966fe1eba</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">97</td><td style="text-align: left">0xcD16E5613EF35599dc82B24Cb45B5A93D779f1EE</td></tr>
<tr><td style="text-align: left">Polygon (Mumbai)</td><td style="text-align: left">5</td><td style="text-align: left">80001</td><td style="text-align: left">0x51a02d0dcb5e52F5b92bdAA38FA013C91c7309A9</td></tr>
<tr><td style="text-align: left">Avalanche (Fuji)</td><td style="text-align: left">6</td><td style="text-align: left">43113</td><td style="text-align: left">0xD601BAf2EEE3C028344471684F6b27E789D9075D</td></tr>
<tr><td style="text-align: left">Oasis (Emerald Testnet)</td><td style="text-align: left">7</td><td style="text-align: left">42261</td><td style="text-align: left">0xC5c25B41AB0b797571620F5204Afa116A44c0ebA</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1313161555</td><td style="text-align: left">0x8F399607E9BA2405D87F5f3e1B78D950b44b2e24</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">4002</td><td style="text-align: left">0x63eD9318628D26BdCB15df58B53BB27231D1B227</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">686</td><td style="text-align: left">0x0A693c2D594292B6Eb89Cb50EFe4B0b63Dd2760D</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">787</td><td style="text-align: left">0x96f1335e0AcAB3cfd9899B30b2374e25a2148a6E</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">1001</td><td style="text-align: left">0x94c994fC51c13101062958b567e743f1a04432dE</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">44787</td><td style="text-align: left">0xaCD8190F647a31E56A656748bC30F69259f245Db</td></tr>
<tr><td style="text-align: left">Moonbase alpha</td><td style="text-align: left">16</td><td style="text-align: left">1287</td><td style="text-align: left">0x98A0F4B96972b32Fcb3BD03cAeB66A44a6aB9Edb</td></tr>
</tbody></table>
<h2 id="devnet--tilt"><a class="header" href="#devnet--tilt">Devnet / Tilt</a></h2>
<h3 id="core-bridge-2"><a class="header" href="#core-bridge-2">Core Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left"></td><td style="text-align: left">Bridge1p5gheXUvJ6jGWGeCsgPKgnE3YgdGKRVCMY9o</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left"></td><td style="text-align: left">0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left"></td><td style="text-align: left">terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left"></td><td style="text-align: left">0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</td></tr>
<tr><td style="text-align: left">Algorand</td><td style="text-align: left">8</td><td style="text-align: left"></td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left">NEAR</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">wormhole.test.near</td></tr>
<tr><td style="text-align: left">Terra2</td><td style="text-align: left">18</td><td style="text-align: left"></td><td style="text-align: left">terra14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9ssrc8au</td></tr>
<tr><td style="text-align: left">Aptos</td><td style="text-align: left">22</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Wormholechain</td><td style="text-align: left">3104</td><td style="text-align: left"></td><td style="text-align: left">wormhole1ap5vgur5zlgys8whugfegnn43emka567dtq0jl</td></tr>
</tbody></table>
<h3 id="token-bridge-3"><a class="header" href="#token-bridge-3">Token Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left"></td><td style="text-align: left">B6RHG3mfcckmrYN1UhmJzyS1XX3fZKbkeUcpJe9Sy3FE</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left"></td><td style="text-align: left">0x0290FB167208Af455bB137780163b7B7a9a10C16</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left"></td><td style="text-align: left">terra10pyejy66429refv3g35g2t7am0was7ya7kz2a4</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left"></td><td style="text-align: left">0x0290FB167208Af455bB137780163b7B7a9a10C16</td></tr>
<tr><td style="text-align: left">Algorand</td><td style="text-align: left">8</td><td style="text-align: left"></td><td style="text-align: left">6</td></tr>
<tr><td style="text-align: left">NEAR</td><td style="text-align: left">15</td><td style="text-align: left"></td><td style="text-align: left">token.test.near</td></tr>
<tr><td style="text-align: left">Terra2</td><td style="text-align: left">18</td><td style="text-align: left"></td><td style="text-align: left">terra1nc5tatafv6eyq7llkr2gv50ff9e22mnf70qgjlv737ktmt4eswrquka9l6</td></tr>
<tr><td style="text-align: left">Aptos</td><td style="text-align: left">22</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Wormholechain</td><td style="text-align: left">3104</td><td style="text-align: left"></td><td style="text-align: left">wormhole1zugu6cajc4z7ue29g9wnes9a5ep9cs7yu7rn3z</td></tr>
</tbody></table>
<h3 id="nft-bridge-3"><a class="header" href="#nft-bridge-3">NFT Bridge</a></h3>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Network ID</th><th style="text-align: left">Address</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left"></td><td style="text-align: left">NFTWqJR8YnRVqPDvTJrYuLrQDitTG5AScqbeghi4zSA</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left"></td><td style="text-align: left">0x26b4afb60d6c903165150c6f0aa14f8016be4aec</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">3</td><td style="text-align: left"></td><td style="text-align: left">terra1plju286nnfj3z54wgcggd4enwaa9fgf5kgrgzl</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left"></td><td style="text-align: left">0x26b4afb60d6c903165150c6f0aa14f8016be4aec</td></tr>
</tbody></table>
<h2 id="blockchain-finality-recommendations"><a class="header" href="#blockchain-finality-recommendations">Blockchain Finality Recommendations</a></h2>
<p>The goal of Wormhole is to provide high confidence that only <em>finalized</em> messages are observed and attested. Different chains use different consensus mechanisms and so there are different finality assumptions with each one.</p>
<p>Below is a table of suggested finality recommendations for each of the chains supported by the Wormhole ecosystem to have the highest confidence of finality.</p>
<p>However, these are just suggestions and developers are free to define their own finality windows for their applications. Ultimately, the tradeoff is between speed and security.</p>
<table><thead><tr><th style="text-align: left">Chain Name</th><th style="text-align: left">Wormhole Chain ID</th><th style="text-align: left">Suggested Number of Block Confirmations</th></tr></thead><tbody>
<tr><td style="text-align: left">Solana</td><td style="text-align: left">1</td><td style="text-align: left">32</td></tr>
<tr><td style="text-align: left">Ethereum</td><td style="text-align: left">2</td><td style="text-align: left">15</td></tr>
<tr><td style="text-align: left">Terra Classic</td><td style="text-align: left">3</td><td style="text-align: left">Instant</td></tr>
<tr><td style="text-align: left">Binance Smart Chain</td><td style="text-align: left">4</td><td style="text-align: left">15</td></tr>
<tr><td style="text-align: left">Polygon</td><td style="text-align: left">5</td><td style="text-align: left">512</td></tr>
<tr><td style="text-align: left">Avalanche (C-Chain)</td><td style="text-align: left">6</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Oasis (Emerald)</td><td style="text-align: left">7</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Aurora</td><td style="text-align: left">9</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Fantom</td><td style="text-align: left">10</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Karura</td><td style="text-align: left">11</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Acala</td><td style="text-align: left">12</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Klaytn</td><td style="text-align: left">13</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Celo</td><td style="text-align: left">14</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">Terra</td><td style="text-align: left">18</td><td style="text-align: left">Instant</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-nodes"><a class="header" href="#rpc-nodes">RPC Nodes</a></h1>
<p>These RPC nodes are maintained by the Guardians to help fetch VAAs and query the Wormhole network.</p>
<h2 id="mainnet-guardian-rpc"><a class="header" href="#mainnet-guardian-rpc">Mainnet Guardian RPC</a></h2>
<pre><code>https://wormhole-v2-mainnet-api.certus.one
https://wormhole.inotel.ro
https://wormhole-v2-mainnet-api.mcf.rocks
https://wormhole-v2-mainnet-api.chainlayer.network
https://wormhole-v2-mainnet-api.staking.fund
https://wormhole-v2-mainnet.01node.com
</code></pre>
<h2 id="testnet-guardian-rpc"><a class="header" href="#testnet-guardian-rpc">Testnet Guardian RPC</a></h2>
<pre><code>https://wormhole-v2-testnet-api.certus.one
</code></pre>
<h2 id="testnet-guardian-public-key"><a class="header" href="#testnet-guardian-public-key">Testnet Guardian Public Key</a></h2>
<pre><code>0x13947Bd48b18E53fdAeEe77F3473391aC727C638
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
